<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Eneter.Messaging.Framework</name>
    </assembly>
    <members>
        <member name="T:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancerFactory">
            <summary>
            Declares the factory for load balancers.
            </summary>
            <remarks>
            The load balancer distributes the workload across a farm of receivers that can run on different machines (or threads).
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancerFactory.CreateLoadBalancer">
            <summary>
            Creates the load balancer.
            </summary>
            <returns>load balancer</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory">
            <summary>
            Implements the factory to create the bidirectional dispatcher.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcherFactory">
            <summary>
            Declares the factory to create the bidirectional dispatcher.
            </summary>
            <remarks>
            The bidirectional dispatcher sends messages to all duplex output channels and also can route back response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcherFactory.CreateDuplexDispatcher">
            <summary>
            Creates the duplex dispatcher.
            </summary>
            <returns>duplex dispatcher</returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the duplex dispatcher factory.
            </summary>
            <param name="duplexOutputChannelsFactory">
            the messaging system factory used to create duplex output channels
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory.CreateDuplexDispatcher">
            <summary>
            Creates the duplex dispatcher.
            </summary>
            <returns>duplex dispatcher</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory">
            <summary>
            Implents the factory creating broker and broker client.
            </summary>
            <remarks>
            The broker is the component that provides functionality for publish-subscribe scenarios.
            IDuplexBrokerClient provides functionality to send notification messages to the broker
            and also to subscribe for desired messages.
            
            <example>
            The example shows how to create and use the broker communicating via TCP.
            <code>
            // Create Tcp based messaging.
            IMessagingSystemFactory aMessagingFactory = new TcpMessagingSystemFactory();
            
            // Create duplex input channel listening to messages.
            IDuplexInputChannel anInputChannel = aMessagingFactory.CreateDuplexInputChannel("tcp://127.0.0.1:7980/");
            
            // Create the factory for the broker.
            IDuplexBrokerFactory aBrokerFactory = new DuplexBrokerFactory();
            
            // Create the broker.
            IDuplexBroker aBroker = aBrokerFactory.CreateBroker();
            
            // Attach the Tcp duplex input channel to the broker and start listening.
            aBroker.AttachDuplexInputChannel(anInputChannel);
            </code>
            
            <code>
            Subscribing for the notification messages.
            
            // Create Tcp based messaging for the silverlight client.
            IMessagingSystemFactory aTcpMessagingFactory = new TcpMessagingSystemFactory();
            
            // Create duplex output channel to send and receive messages.
            myOutputChannel = aTcpMessagingFactory.CreateDuplexOutputChannel("tcp://127.0.0.1:7980/");
            
            // Create the broker client
            IDuplexBrokerFactory aDuplexBrokerFactory = new DuplexBrokerFactory();
            myBrokerClient = aDuplexBrokerFactory.CreateBrokerClient();
            
            // Handler to process notification messages.
            myBrokerClient.BrokerMessageReceived += NotifyMessageReceived;
            
            // Attach the channel to the broker client to be able to send and receive messages.
            myBrokerClient.AttachDuplexOutputChannel(myOutputChannel);
            
            // Subscribe in broker to receive chat messages.
            myBrokerClient.Subscribe("MyChatMessageType");
            
            
            ...
            
            
            // Send message to the broker. The broker will then forward it to all subscribers.
            XmlStringSerializer anXmlSerializer = new XmlStringSerializer();
            object aSerializedChatMessage = anXmlSerializer.Serialize&lt;ChatMessage&gt;(aChatMessage);
            myBrokerClient.SendMessage("MyChatMessageType", aSerializedChatMessage);
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory">
            <summary>
            Declares the factory to create the broker and the broker client.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory.CreateBrokerClient">
            <summary>
            Creates the broker client.
            </summary>
            <remarks>
            The broker client is able to send messages to the broker (via attached duplex output channel).
            It also can subscribe for messages to receive notifications from the broker.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory.CreateBroker">
            <summary>
            Creates the broker.
            </summary>
            <remarks>
            The broker receives messages and forwards them to subscribers.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor">
            <summary>
            Constructs the broker factory with XmlStringSerializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the broker factory with specified serializer.
            </summary>
            <param name="serializer">serializer used by the broker</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.CreateBrokerClient">
            <summary>
            Creates the broker client.
            </summary>
            <remarks>
            The broker client is able to send messages to the broker (via attached duplex output channel).
            It also can subscribe for messages to receive notifications from the broker.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.CreateBroker">
            <summary>
            Creates the broker.
            </summary>
            <remarks>
            The broker receives messages and forwards them to subscribers.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.BrokerNotifyMessage">
            <summary>
            The data representing the message sent to the broker to notify subscribed clients.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerNotifyMessage.#ctor">
            <summary>
            Default constructor used for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerNotifyMessage.#ctor(System.String,System.Object)">
            <summary>
            Constructs the message data from the input parameters.
            </summary>
            <param name="messageTypeId">Type of the notified message.</param>
            <param name="message">Message content.</param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerNotifyMessage.MessageTypeId">
            <summary>
            Type of the notified message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerNotifyMessage.Message">
            <summary>
            Serialized message that shall be notified to subscribers.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Bridge.IBridgeFactory">
            <summary>
            Declares the factory to create Bridge for one-way messaging and DuplexBridge for request-response
            messaging. 
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Bridge.IBridgeFactory.CreateBridge">
            <summary>
            Creates the bridge to send one-way messages.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Bridge.IBridgeFactory.CreateDuplexBridge(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,System.String)">
            <summary>
            Creates the duplex bridge to send request-response messages.
            </summary>
            <param name="messagingSystemFactory">messaging system used to create duplex output channel to forward the incoming message</param>
            <param name="channelId">channel id where the bridge sends messages.</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory">
            <summary>
            Implements the messaging system delivering messages via websockets.
            </summary>
            <remarks>
            It creates the communication channels using WebSockets for sending and receiving messages.
            The channel id must be a valid URI address. E.g.: ws://127.0.0.1:6080/MyService/. <br/>
            Notice, Silverlight and Windows Phone do not support TCP listeners and therefore WebSocket listeners are not suported too.
            Therefore, only sending messages (and receiving response messages) is possible on these platforms.<br/>
            More details:<br/>
            TCP in Silverlight is restricted to ports 4502 - 4532 and requires the TcpPolicyServer running on the service side.<br/>
            Windows Phone 7.0 does not suport TCP at all. The TCP is supported from Windows Phone 7.1. TCP in Windows Phone 7.1
            does not require TcpPolicyServer and is not restricted to certain ports as in Silverlight. 
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory">
            <summary>
            Declares the factory that creates communication channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the specified input channel.
            </summary>
            <remarks>
            The output channel can send messages only to the input channel and not to the duplex input channel.
            </remarks>
            <param name="channelId">identifies the receiving input channel</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel.
            </summary>
            <remarks>
            The input channel listens on the address specified by the channel id.<br/>
            The input channel can receive messages only from the output channel and not from the duplex output channel.
            </remarks>
            <param name="channelId">identifies the address, the input channel listens to</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <param name="responseReceiverId">unique identifier of the response receiver represented by this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">identifies the address, the duplex input channel listens to</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.#ctor">
            <summary>
            Constructs the WebSocket messaging factory.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.EConcurrencyMode)">
            <summary>
            Constructs the WebSocket messaging factory.
            </summary>
            <param name="concurrencyMode">
            Specifies the threading mode for receiving messages in input channel and duplex input channel.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.EConcurrencyMode,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the WebSocket messaging factory.
            </summary>
            <param name="concurrencyMode">
            Specifies the threading mode for receiving messages in input channel and duplex input channel.</param>
            <param name="protocolFormatter">formatter used for low-level messaging between output and input channels.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the specified input channel by using WebSocket.
            </summary>
            <remarks>
            The output channel can send messages only to the input channel and not to the duplex input channel.
            </remarks>
            <param name="channelId">Identifies the receiving output channel. The channel id must be a valid URI address e.g. ws://127.0.0.1:8090/MyService/ </param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from output channel by using WebSocket.<br/>
            The method is not supported in Silverlight and Windows Phone.
            </summary>
            <remarks>
            The input channel can receive messages only from the output channel and not from the duplex output channel.
            </remarks>
            <param name="channelId">The addres, the input channel will listen to. The channel id must be a valid URI address e.g. ws://127.0.0.1:8090/MyService/ </param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using WebSocket.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid URI address e.g. ws://127.0.0.1:8090/MyService/ </param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using WebSocket.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid URI address e.g. ws://127.0.0.1:8090/ </param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using WebSocket.
            The method is not supported in Silverlight and Windows Phone.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">Identifies this duplex input channel. The channel id must be a valid URI address (e.g. ws://127.0.0.1:8090/MyService/) the input channel will listen to.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.ServerSecurityStreamFactory">
            <summary>
            Sets or gets the security stream factory for the server.
            If the factory is set, then the input channel and the duplex input channel use it to establish
            the secure communication.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.ClientSecurityStreamFactory">
            <summary>
            Sets and gets the security stream factory for the client.
            If the factory is set, then the output channel and the duplex output channel use it to establish
            the secure communication.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory">
            <summary>
            The factory class implements the messaging system delivering messages synchronously in the caller thread.
            It creates output and input channels using the caller thread to deliver messages.
            <br/><br/>
            Different instances of SynchronousMessagingSystemFactory are independent and so they
            are different messaging systems. Therefore if you want to send/receive a message through this messaging system
            then output and input channels must be created with the same instance of SynchronousMessagingSystemFactory.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory representing the messaging system.
            Note: Every instance of the synchronous messaging system factory represents one messaging system.
                  It means that two instances of this factory class creates channels for two independent messaging system.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the factory representing the messaging system.
            </summary>
            <param name="protocolFromatter">formatter used to encode low-level messages between channels</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to specified input channel using the synchronous local call.
            </summary>
            <param name="channelId">identifies the receiving input channel</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages on the specified channel id via the synchronous local call.
            </summary>
            <param name="channelId">identifies this input channel</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel communicating with the specified duplex input channel using synchronous local call.
            The duplex output channel can send messages and receive response messages.
            </summary>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel communicating with the specified duplex input channel using synchronous local call.
            The duplex output channel can send messages and receive response messages.
            </summary>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <param name="responseReceiverId">identifies the response receiver of this duplex output channel</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel listening to messages on the specified channel id.
            The duplex input channel can send response messages back to the duplex output channel.
            </summary>
            <param name="channelId">identifies this duplex input channel</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel">
            <summary>
            Declares the duplex input channel that can receive messages from the duplex output channel and send back response messages.
            </summary>
            <remarks>
            Notice, the duplex input channel works only with duplex output channel and not with output channel.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.StartListening">
            <summary>
            Starts listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.StopListening">
            <summary>
            Stops listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.SendResponseMessage(System.String,System.Object)">
            <summary>
            Sends the response message back to the connected IDuplexOutputChannel.
            </summary>
            <param name="responseReceiverId">Identifies the response receiver. The identifier comes with received messages.</param>
            <param name="message">response message</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.DisconnectResponseReceiver(System.String)">
            <summary>
            Disconnects the response receiver.
            </summary>
            <param name="responseReceiverId">identifies the response receiver</param>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.MessageReceived">
            <summary>
            The event is invoked when a message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverConnected">
            <summary>
            The event is invoked when a duplex output channel opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a duplex output channel closed the connection.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ChannelId">
            <summary>
            Returns id of this duplex input channel.
            The id represents the 'address' the duplex input channel is listening to.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.IsListening">
            <summary>
            Returns true if the duplex input channel is listening.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel">
            <summary>
            Declares the input channel that can receive messages from the output channel.
            </summary>
            <remarks>
            Notice, the input channel can receive messages only from the output channel.
            It cannot receive messages from the duplex output channel.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.StartListening">
            <summary>
            Starts listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.StopListening">
            <summary>
            Stops listening.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.MessageReceived">
            <summary>
            The event is invoked when a message was received.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.ChannelId">
            <summary>
            Returns id of the channel.
            The channel id represents the address the receiver is listening to.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.IsListening">
            <summary>
            Returns true if the input channel is listening.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel">
            <summary>
            Declares the output channel that can send messages to the input channel.
            </summary>
            <remarks>
            Notice, the output channel can send messages only to the input channel and not to the duplex input channel.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel.SendMessage(System.Object)">
            <summary>
            Sends the message.
            </summary>
            <remarks>
            Notice, there is a limitation for the Silverlight platform using HTTP.
            If the message is sent via HTTP from the main Silverlight thread, then in case of a failure, the exception is not thrown.
            Therefore, it is recommended to execute this method in a different thread.
            </remarks>
            <param name="message">serialized message</param>
            <exception cref="T:System.Exception">Any exception thrown during sending of a message. E.g. if sending via TCP fails.</exception>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel.ChannelId">
            <summary>
            Returns the id representing the address where messages are sent.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transferring messages via HTTP.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel">
            <summary>
            Implements the duplex output channel based on Http.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel">
            <summary>
            Declares the duplex output channel that can send messages to the duplex input channel and receive response messages.
            </summary>
            <remarks>
            Notice, the duplex output channel works only with duplex input channel and not with input channel.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.SendMessage(System.Object)">
            <summary>
            Sends the message to the address represented by ChannelId.
            </summary>
            <remarks>
            Notice, there is a limitation for the Silverlight platform using HTTP.
            If the message is sent via HTTP from the main Silverlight thread, then in case of a failure, the exception is not thrown.
            Therefore, it is recommended to execute this method in a different thread.
            </remarks>
            <exception cref="T:System.InvalidOperationException">If the connection is not open.</exception>
            <exception cref="T:System.Exception">Any exception thrown during sending of a message. E.g. if sending via TCP fails.</exception>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.OpenConnection">
            <summary>
            Opens the connection with the duplex input channel.
            </summary>
            <remarks>
            Notice, there is a limitation for the Silverlight platform using HTTP.
            If the message is sent via HTTP from the main Silverlight thread, then in case of a failure, the exception is not thrown.
            Therefore, it is recommended to execute this method in a different thread.
            </remarks>
            <exception cref="T:System.InvalidOperationException">If the connection is already open.</exception>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.CloseConnection">
            <summary>
            Closes the connection with the duplex input channel.
            </summary>
            <remarks>
            Notice, there is a limitation for the Silverlight platform.
            If this method is executed in the main Silverlight thread, then in case of a failure the exception will not be propagated.
            It is recommended to execute this method in a different thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ResponseMessageReceived">
            <summary>
            The event is invoked when a response message was received.
            </summary>
            <remarks>
            Notice, this event is invoked in a different thread. The exception is only the Synchronous messaging that
            invokes this event in the thread calling the method SendResponseMessage in <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel"/>.
            Also, in Silverlight (and Windows Phone 7), http and tcp messagings have the possibility
            to choose if the thread shall be the main Silverlight thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionOpened">
            <summary>
            The event is invoked when the connection with the duplex input channel was opened.
            </summary>
            <remarks>
            Notice, the event is invoked in a thread from the thread pool. Therefore, if you need to manipulate UI,
            do not forget to marshal it to the UI thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed">
            <summary>
            The event is invoked when the connection with the duplex input channel was closed.
            </summary>
            <remarks>
            Notice, the event is invoked in a thread from the thread pool. Therefore, if you need to manipulate UI,
            do not forget to marshal it to the UI thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ChannelId">
            <summary>
            Returns the id of the duplex input channel where messages are sent.
            It represents the address where messages are sent.
            </summary>
            <remarks>
            The channel id represents the communication address. The syntax of the channel id depends on the chosen
            communication. If the messaging is based on http, the address would be e.g.: http://127.0.0.1/Something/ or
            http://127.0.0.1:7345/Something/. If the communication is based on tcp, the address would be e.g.: tcp://127.0.0.1:7435/.
            For the named pipe, e.g. net.pipe://127.0.0.1/SomePipeName/.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ResponseReceiverId">
            <summary>
            Returns response receiving id of the duplex output channel.
            </summary>
            <remarks>
            The response receiver id is a unique identifier used by the duplex input channel to recognize
            connected duplex output channels.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.IsConnected">
            <summary>
            Returns true if the duplex output channel is connected to the duplex input channel and listens to response messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.CloseConnection">
            <summary>
            Stops pulling for response messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.SendMessage(System.Object)">
            <summary>
            Sends the message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.DoPolling">
            <summary>
            Implements the loop receiving response messages.
            The receiving the response messages is implemented as pulling on a regular basis according to the
            frequency specified in the constructor.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.HandleResponseMessage(Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage)">
            <summary>
            Handles response messages from the queue.
            </summary>
            <param name="protocolMessage"></param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.ChannelId">
            <summary>
            Returns the channel id. - the channel id is Uri.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.IsConnected">
            <summary>
            Returns true if the connection is open.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel">
            <summary>
            Declares the reliable duplex input channel.
            </summary>
            <remarks>
            It behaves like <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel"/> and can also be used everywhere where <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel"/>
            is required.<br/>
            In addition, the reliable duplex input channel provides events <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.ResponseMessageDelivered"/> and
            <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.ResponseMessageNotDelivered"/>.
            The method <see cref="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.SendResponseMessage(System.String,System.Object)"/> returns unique id of the sent message.
            <br/><br/>
            The reliable duplex input channel can receive messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/>.
            It cannot receive messages from <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel"/>.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexInputChannel">
            <summary>
            The interface declares the composit duplex input channel.
            The composit duplex input channel is the duplex input channel that uses underlying duplex input channel
            to receive messages and send respones messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexInputChannel.UnderlyingDuplexInputChannel">
            <summary>
            Returns the underlying duplex input channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.SendResponseMessage(System.String,System.Object)">
            <summary>
            Sends the response message.
            </summary>
            <param name="responseReceiverId">identifies the receiver of the response message</param>
            <param name="message">message</param>
            <returns>id of the message</returns>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.ResponseMessageDelivered">
            <summary>
            The event is invoked when the response message was delivered to the reliable duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.ResponseMessageNotDelivered">
            <summary>
            The event is invoked if the response message was not delivered until the specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel">
            <summary>
            The interface declares the composit duplex output channel.
            The composit duplex output channel is the duplex output channel that uses underlying duplex output channel
            to send messages and receive response mssages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel.UnderlyingDuplexOutputChannel">
            <summary>
            Returns the underlying duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.NamespaceDoc">
            <summary>
            Extends the messaging system to work temporarily offline while the connection is not available.
            </summary>
            <remarks>
            The buffered messaging is intended to temporarily store sent messages while the network connection is not available.
            Typical scenarios are:
            <br/><br/>
            <b>Short disconnections</b><br/>
            The network connection is unstable and can be anytime interrupted. In case of the disconnection, the sent messages are stored
            in the buffer while the connection tries to be automatically reopen. If the reopen is successful and the connection
            is established, the messages are sent from the buffer.
            <br/><br/>
            <b>Independent startup order</b><br/>
            The communicating applications starts in undefined order and initiates the communication. In case the application receiving
            messages is not up, the sent messages are stored in the buffer. Then when the receiving application is running, the messages
            are automatically sent from the buffer.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel">
            <summary>
            The interface declares methods to attach/detach one IDuplexInputChannel.
            </summary>
            <remarks>
            The duplex input channel is used in the request-response communication by a listener
            to receive request messages and send back response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.AttachDuplexInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel and starts listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.DetachDuplexInputChannel">
            <summary>
            Detaches the duplex input channel and stops listening to messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.IsDuplexInputChannelAttached">
            <summary>
            Returns true if the duplex input channel is attached.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.AttachedDuplexInputChannel">
            <summary>
            Retutns attached duplex input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageReceiver`2">
            <summary>
            The interface declares the duplex receiver for sequence of typed messages.
            The receiver is able to receive sequence of messages of specified type and response the sequence of messages
            of specified type. <br/>
            It is guaranteed the sequence is received in the same order as was sent. <br/>
            <b>Note: Be aware that if the 'thread pool messaging system' is chosen the incoming messages
            are processed in more threads in parallel. Therefore the 'thread pool messaging system'
            cannot guarantee the order of incoming messages. <br/>
            Consider to use the 'thread messaging system' instead.
            </b>
            </summary>
            <typeparam name="_ResponseType">The type of sending response messages.</typeparam>
            <typeparam name="_RequestType">The type of the receiving messages.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageReceiver`2.SendResponseMessage(System.String,`0,System.String,System.Boolean)">
            <summary>
            Sends the response message to the specified duplex typed sequenced message sender.
            </summary>
            <param name="responseReceiverId">specifies the duplex typed sequenced message sender that will receive the response</param>
            <param name="responseMessage">message</param>
            <param name="sequenceId">identifies the sequence the message is part of</param>
            <param name="isSequenceCompleted">true - indicates the sequence is completed</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageReceiver`2.MessageReceived">
            <summary>
            The event is invoked when the message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageReceiver`2.ResponseReceiverConnected">
            <summary>
            The event is invoked when the duplex typed sequenced message sender opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageReceiver`2.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the duplex typed sequenced message sender closed the connection.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1">
            <summary>
            The event when the typed message is received.
            </summary>
            <typeparam name="_RequestMessageType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.#ctor(System.String,`0)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseReceiverId">identifies the client where the response can be sent</param>
            <param name="requestMessage">message</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.#ctor(System.String,System.Exception)">
            <summary>
            Constructs the message from the exception.
            </summary>
            <param name="responseReceiverId">identifies the client where the response can be sent</param>
            <param name="error">error detected during receiving the message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.RequestMessage">
            <summary>
            Returns the received message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.ResponseReceiverId">
            <summary>
            Returns the client identifier where the response can be sent.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessagesFactory">
            <summary>
            The interface declares the factory to create reliable typed message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageSender``2">
            <summary>
            Creates reliable typed message sender.
            </summary>
            <typeparam name="_ResponseType">type of response messages</typeparam>
            <typeparam name="_RequestType">type of request messages</typeparam>
            <returns>reliable typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageReceiver``2">
            <summary>
            Creates reliable typed message receiver.
            </summary>
            <typeparam name="_ResponseType">type of response messages</typeparam>
            <typeparam name="_RequestType">type of request messages</typeparam>
            <returns>reliable typed message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessagesFactory">
            <summary>
            The interface declares the factory to create reliable string message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessagesFactory.CreateReliableDuplexStringMessageSender">
            <summary>
            Creates the reliable string message sender.
            </summary>
            <returns>reliable string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessagesFactory.CreateReliableDuplexStringMessageReceiver">
            <summary>
            Creates the reliable string message receiver.
            </summary>
            <returns>reliable string message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2">
            <summary>
            The interface declares the reliable command proxy.
            The command proxy is able to send the request to execute some activity in the respective command.
            The command proxy is also able to request pause, resume or cancel.
            It receive response messages from the command.
            In addition, the reliable command proxy notifies whether the request message was delivered.
            The reliable command proxy can be used only with the reliable command.
            </summary>
            <typeparam name="_ReturnDataType">Type of return data.</typeparam>
            <typeparam name="_InputDataType">Type of input data.</typeparam>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableOutputChannel">
            <summary>
            The interface declares methods to attach/detach IReliableOutputChannel
            </summary>
            <remarks>
            For more details about the reliable output channel see <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/>.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableOutputChannel.AttachReliableOutputChannel(Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel)">
            <summary>
            Attaches the reliable output channel and starts listening to response messages.
            </summary>
            <param name="reliableOutputChannel"></param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableOutputChannel.DetachReliableOutputChannel">
            <summary>
            Detaches the reliable output channel and stops listening to response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableOutputChannel.IsReliableOutputChannelAttached">
            <summary>
            Returns true if the reliable output channel is attached.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableOutputChannel.AttachedReliableOutputChannel">
            <summary>
            Returns attached reliable output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.Pause(System.String)">
            <summary>
            Sends the pause request to the command.
            </summary>
            <param name="commandId">identifies the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.Resume(System.String)">
            <summary>
            Sends the resume request to the command.
            </summary>
            <param name="commandId">identifies the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.Cancel(System.String)">
            <summary>
            Sends the cancel request to the command.
            </summary>
            <param name="commandId">identifies the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.Execute(System.String)">
            <summary>
            Sends the execute request to the command.
            </summary>
            <param name="commandId">identifies particular command e.g. when the proxy invokes more commands</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.Execute(System.String,`1)">
            <summary>
            Sends the execute request to the command.
            </summary>
            <param name="commandId">identifies particular command e.g. when the proxy invokes more commands</param>
            <param name="inputData">input data</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.Execute(System.String,`1,System.String,System.Boolean)">
            <summary>
            Sends the execute request to the command.
            The input data is sent as a sequence.
            </summary>
            <param name="commandId">identifies particular command e.g. when the proxy invokes more commands</param>
            <param name="inputData">input data</param>
            <param name="sequenceId">input data sequence identifier</param>
            <param name="isSequenceCompleted">true - if the sequence is completed</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.CommandResponseReceived">
            <summary>
            The event is invoked when the response message from the command was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.MessageDelivered">
            <summary>
            The event is invoked when the message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.MessageNotDelivered">
            <summary>
            The message is invoked if the message was not delivered until specified time.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ReliableCommandProxy`2.myDuplexOutputChannelId">
            <summary>
            This is used only for trace purposes.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandRequestEventArgs">
            <summary>
            Event data when a request was received in the command.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandRequestEventArgs.#ctor(System.String,System.String)">
            <summary>
            Constructs the event data.
            </summary>
            <param name="commandProxyId">identifier of the command proxy that sent the request</param>
            <param name="commandId">command identifier</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandRequestEventArgs.CommandProxyId">
            <summary>
            Gets the identifier of the command proxy that sent the request.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandRequestEventArgs.CommandId">
            <summary>
            Gets command identifier.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Wrapping.NamespaceDoc">
            <summary>
            Functionality for wrapping and unwrapping serialized data.
            </summary>
            <remarks>
            The wrapping functionality allows to extended already serialized data by some additional data.
            <example>
            The example shows how to extend already serialized data by time stamp.
            <code>
            // Serialization into the xml string.
            XmlStringSerializer aSerializer = new XmlStringSerializer();
            
            // Get the time stamp.
            DateTime aTimeStamp = DateTime.Now;
            
            // Add the the time stamp to already serialized data.
            // Note: It creates the 'WrappedData' class containing both time stamp and original serialized data
            //       and serializes it by the provided serializer.
            object aWrappedSerializedData = DataWrapper.Wrap(aTimeStamp, anAlreadySerializedData, aSerializer)
            
            ...
            
            // Deserialization.
            // 1. Data must be unwrapped.
            WrappedData aWrappedData = DataWrapper.Unwrap(aWrappedSerializedData, aSerializer);
            
            // 2. Read the time stamp.
            DateTime aTimeStamp = (DateTime)aWrappedData.AddedData;
            
            // 3. Continue in processing of originally serialized data.
            object anOriginalSerializedData = aWrappedData.OriginalData;
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.NamespaceDoc">
            <summary>
            The namespace contains the supporting functionality to sequence data.
            </summary>
            <remarks>
            The sequencing allows to put data into the sequence. The data in the sequence
            are ordered. The sequencing can be used in cases where data must be received in
            the same order as was sent. See also <see cref="N:Eneter.Messaging.EndPoints.TypedSequencedMessages"/>.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.IFragmentProcessor">
            <summary>
            The interface declares the fragment processor.
            The fragment processor is used to process incoming fragments. Fragment processors can implement
            various strategies how to process fragments.<br/>
            The fragment processor is intended to process one sequence of fragments.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.IFragmentProcessor.ProcessFragment(Eneter.Messaging.DataProcessing.Sequencing.IFragment)">
            <summary>
            Processes the fragment and returns the sequence of processed fragments ready for the user.
            If the processing of the fragment do not result in a sequence for the user it can return the empty sequence.<br/>
            
            E.g.: It can happen the fragments of the sequence do not come in the right order. Therefore the processing
                  can hold such fragments and return the empty sequence. Then later when it is possible to return
                  fragments in the correct order the processing can return the sequence with fragments.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.IFragmentProcessor.SequenceId">
            <summary>
            Returns the sequence identifier processing by the fragment processor.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.IFragmentProcessor.IsWholeSequenceProcessed">
            <summary>
            Returns true if the whole sequence is processed.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentSequencer.#ctor(System.String)">
            <summary>
            The constructor initializes the sequencer for a particular instance.
            </summary>
            <param name="sequenceId"></param>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.FragmentDataFactory">
            <summary>
            The factory class provides methods to create fragment processors.
            The fragment processors provides strategies to process incoming fragments of data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentDataFactory.CreateFragmentSequencer(System.String)">
            <summary>
            Creates the fragment processor ordering the incoming sequence of fragments.
            The sequencer receives data fragments and continuously returns the sequence of ordered fragments.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentDataFactory.CreateSequenceFinalizer(System.String)">
            <summary>
            Creates the fragment processor ordering the incoming sequence of fragments.
            The sequencer receives data fragments and when the whole sequence is collected it returns it.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentDataFactory.CreateMultiinstanceFragmentProcessor(System.Func{System.String,Eneter.Messaging.DataProcessing.Sequencing.IFragmentProcessor})">
            <summary>
            Creates the fragment processor able to process more sequences at once.
            </summary>
            <param name="fragmentProcessorFactoryMethod">
            Factory method used to create processors for particular sequences.
            Note: CreateFragmentSequencer() and CreateSequenceFinalizer() from this factory class can be used as factory methods.
            </param>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.IInvoker">
            <summary>
            Declares universal invoker of a method.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelWrapper">
            <summary>
            Declares the duplex channel wrapper.
            </summary>
            <remarks>
            The duplex channel wrapper is listening to more duplex input channels. When it receives some message,
            it wraps the message and sends it via the only duplex output channel.
            On the other side the message is received by duplex channel unwrapper. The unwrapper unwraps the message
            and uses the duplex output channel to forward the message to the correct receiver.<br/>
            The receiver can also send the response message. Then it goes the same way back.<br/>
            Notice, the 'duplex channel wrapper' can communication only with 'duplex channel unwrapper'.
            It cannot communicate with one-way 'channel unwrapper'.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels">
            <summary>
            The interface declares methods to attach/detach multiple IDuplexInputChannel.
            </summary>
            <remarks>
            Some comunication components need to attach several channels. E.g. <see cref="T:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher"/>. <br/>
            Component using multiple duplex input channels is used in request-response communication and is
            able to listen to requests on more channels (addresses) and send back (to the right sender) the response message.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.AttachDuplexInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel nad starts listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.DetachDuplexInputChannel">
            <summary>
            Detaches the duplex input channel.
            Detaching the input channel stops listening to the messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.DetachDuplexInputChannel(System.String)">
            <summary>
            Detaches the duplex input channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.IsDuplexInputChannelAttached">
            <summary>
            Returns true if the duplex input channel is attached.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.AttachedDuplexInputChannels">
            <summary>
            Returns attached input channels.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel">
            <summary>
            The interface declares methods to attach/detach one IDuplexOutputChannel.
            </summary>
            <remarks>
            The duplex output channel is used in the request-response communication by a sender
            to send request messages and receive response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.AttachDuplexOutputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel)">
            <summary>
            Attaches the duplex output channel and opens the connection for listening to response messages.
            </summary>
            <param name="duplexOutputChannel">Duplex output channel to be attached.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.DetachDuplexOutputChannel">
            <summary>
            Detaches the duplex output channel and stops listening to response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.IsDuplexOutputChannelAttached">
            <summary>
            Returns true if the reference to the duplex output channel is stored. <br/>
            </summary>
            <remarks>
            Notice, unlike version 1.0, the value 'true' does not mean the connection is open. If the duplex output
            channel was successfuly attached but the connection was broken, the channel stays attached but the connection is not open.
            To detect if the attached channel is listening to response messages, check the property <see cref="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.IsConnected"/>.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.AttachedDuplexOutputChannel">
            <summary>
            Returns attached duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.NamespaceDoc">
            <summary>
            Functionality for publish-subscribe scenarios. Clients can subscribe for notification messages.
            </summary>
            <remarks>
            The broker is intended for publish-subscribe scenarios. Clients can use the broker to subscribe for messages
            or for sending of notification messages.<br/>
            The broker works like this:<br/>
            The client has some event that wants to notify to everybody who is interested. It sends the message to the broker.
            The broker receives the message and forwards it to everybody who is subscribed for such event.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketInputChannelBase.HandleConnection(Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext)">
            <summary>
            The method is called in a separate thread when the connection is established.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketDuplexInputChannel.SendResponseMessage(System.String,System.Object)">
            <summary>
            Sends the response message back to the TcpDuplexOutputChannel.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketDuplexInputChannel.HandleConnection(Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext)">
            <summary>
            The method is called in a separate thread when the connection is established.
            </summary>
            <param name="client"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketDuplexInputChannel.TClient">
            <summary>
            The internal class representing the connection with the client.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketDuplexInputChannel.TClient.Client">
            <summary>
            Returns Tcp client.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.NamespaceDoc">
            <summary>
            Functionality extending the default behavior of messaging systems.
            </summary>
            <remarks>
            E.g.: Buffering of sent messages, reliable communication or network connection monitoring.<br/>
            The extensions are realized by so called 'composites'. The composite is a messaging system derived from
            <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory"/> that implements the extending functionality but for the communication
            it uses other (underlying) messaging system. It means, e.g. if you wish the buffered messaging for the TCP based communication,
            you can create the buffered messaging system using the TCP as the underlying messaging system.
            <example>
            Creating of the buffered messaging using the TCP as the underlying messaging system.
            <code>
            // Create TCP messaging system.
            IMessagingSystemFactory anUnderlyingMessaging = new TcpMessagingSystemFactory();
            
            // Create the buffered messaging using TCP as the underlying messaging.
            IMessagingSystemFactory aBufferedMessaging = new BufferedMessagingFactory(anUnderlyingMessaging);
            </code>
            </example>
            Therefore, messaging systems can be composed into layers providing the desired functionality. It is also possible
            to use a composite messaging system as the underlying messaging.
            <example>
            Creating the TCP based messaging system constantly checking the network connection and providing the buffer
            for sent messages in case of the disconnection.
            <code>
            // Create TCP messaging system.
            IMessagingSystemFactory aTcpMessaging = new TcpMessagingSystemFactory();
            
            // Create the composite providing the network connection monitor.
            IMessagingSystemFactory aMonitoredMessaging = new MonitoredMessagingFactory(aTcpMessaging);
            
            // Create the composite providing the buffer used for the sent messages in case of the disconnection.
            IMessagingSystemFactory aBufferedMonitoredMessaging = new BufferedMessagingFactory(aMonitoredMessaging);
            
            
            ...
            
            // Create the duplex output channel, that monitores the network connection and buffers sent messages if disconnected.
            IDuplexOutputChannel aDuplexOutputChannel = aBufferedMonitoredMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:6080/");
            
            </code>
            </example>
            To simplify the implementation, there are already pre-implemented typically composed messaging systems.
            E.g.: <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory"/>. It is the messaging system that is composed from the following
            layers:
            <br/>
            <ol>
            <li>Reliable Messaging  --&gt; provides acknowledged messages.</li>
            <li>Monitored Messaging --&gt; constantly checks the connection.</li>
            <li>Messaging System    --&gt; a real messaging system transferring messages, e.g. TCP messaging system.</li>
            </ol>
            <example>
            Using the pre-implementated messaging to create the reliable communication (acknowledged messages) and with monitored
            network connection.
            <code>
            // Create TCP messaging system.
            IMessagingSystemFactory aTcpMessaging = new TcpMessagingSystemFactory();
            
            // Create the messaging system using the reliable communcation and the monitoring the network connection.
            IReliableMessagingFactory aReliableMessaging  = new ReliableMessagingFactory(aTcpMessaging);
            </code>
            </example>
            <br/>
            Notice, that the communicating applications (or components) must use the same composite messaging system to be able to communicate.
            E.g. if the server application uses ReliableMonitoredMessagingFactory then also the client must use ReliableMonitoredMessagingFactory.
            Otherwise, they will not understand each other.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.NamespaceDoc">
            <summary>
            The reliable messaging, providing the confirmation if the sent message was delivered.
            </summary>
            <remarks>
            The reliable messaging provides the information whether the sent message was delivered.
            If the sent message was delivered, the receiver automatically sends back the acknowledge message.
            If the sender receives the acknowledge message, it notifies, the message was delivered.
            If the sender does not receive the acknowledge message within a specified timeout, it notifies, the message
            was not delivered.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableMessagingFactory">
            <summary>
            Declares the factory for the reliable messaging system.
            </summary>
            <remarks>
            The reliable messaging system extends the underlying messaging system by the functionality providing the information
            whether the sent message was delivered or not.
            <br/><br/>
            Sending of the message from the <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/>:<br/>
            <ol>
            <li>The reliable duplex output channel sends the message.</li>
            <li>The reliable duplex input channel receives the message and automatically sends back the acknowledgement.</li>
            <li>The reliable duplex output channel receives the acknowledging message and notifies, the message was delivered.</li>
            </ol>
            <br/><br/>
            Sending of the response message from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>:<br/>
            <ol>
            <li>The reliable duplex input channel sends the response message.</li>
            <li>The reliable duplex output channel receives the message and automatically sends back the acknowledgement.</li>
            <li>The reliable duplex input channel receives the acknowledging message and notifies, the response message was delivered.</li>
            </ol>
            <br/><br/>
            Notice, since <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel"/> and <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel"/> communicate oneway,
            the reliable communication with acknowledge messages is not applicable for them.
            Therefore, the factory just uses the underlying messaging system to create them.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the reliable duplex output channel that can send messages and receive response messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </summary>
            <remarks>
            It provides notification whether the sent message was delivered or not.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the reliable duplex output channel that can send messages and receive response messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </summary>
            <remarks>
            It provides notification whether the sent message was delivered or not.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">id of the response receiver</param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the reliable duplex input channel that can receiver messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/> and send back
            response messages.
            </summary>
            <remarks>
            It provides notification whether the sent response message was delivered or not.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider">
            <summary>
            The interface declares methods for convenient attaching of channels and
            for connecting senders and receivers with channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel,System.String)">
            <summary>
            Creates and attaches the input channel to the component.
            </summary>
            <param name="inputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels,System.String)">
            <summary>
            Creates and attaches the input channel to the component that can have attached multiple input channels.
            </summary>
            <param name="inputComponent">Component</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel,System.String)">
            <summary>
            Creates and attaches the output channel to the component.
            </summary>
            <param name="outputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels,System.String)">
            <summary>
            Creates and attaches the output channel to the component that can have attached multiple output channels.
            </summary>
            <param name="outputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel,System.String)">
            <summary>
            Creates and attaches the duplex input channel to the component.
            </summary>
            <param name="inputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels,System.String)">
            <summary>
            Creates and attaches the duplex input channel to the component that can have attached multiple duplex input channels.
            </summary>
            <param name="inputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel,System.String)">
            <summary>
            Creates and attaches the duplex output channel to the component.
            </summary>
            <param name="outputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel,Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel,System.String)">
            <summary>
            Creates the input channel and output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">Input channel attachable component (receiver)</param>
            <param name="outputComponent">Output channel attachabel component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel,Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels,System.String)">
            <summary>
            Creates the input channel and output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">input channel attachable component (receiver)</param>
            <param name="outputComponent">multiple output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels,Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels,System.String)">
            <summary>
            Creates the input channel and output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">input channel attachable component (receiver)</param>
            <param name="outputComponent">multiple output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels,Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel,System.String)">
            <summary>
            Creates the input channel and output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">input channel attachable component (receiver)</param>
            <param name="outputComponent">multiple output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel,Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel,System.String)">
            <summary>
            Creates the duplex input channel and duplex output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">duplex input channel attachable component (receiver)</param>
            <param name="outputComponent">duplex output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels,Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel,System.String)">
            <summary>
            Creates the duplex input channel and duplex output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">duplex input channel attachable component (receiver)</param>
            <param name="outputComponent">duplex output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.MessagingSystem">
            <summary>
            Returns the messaging system used by the connection provider.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels">
            <summary>
            The interface declares methods to attach/detach multiple IOutputChannel.
            </summary>
            <remarks>
            Some comunication components need to attach several channels.
            Components using multiple output channels are used in one-way communication.
            They are able to send messages to several receivers. E.g. <see cref="T:Eneter.Messaging.Nodes.Dispatcher.IDispatcher"/>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels.AttachOutputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel)">
            <summary>
            Attaches the output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels.DetachOutputChannel">
            <summary>
            Detaches all output channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels.DetachOutputChannel(System.String)">
            <summary>
            Detaches the output channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels.IsOutputChannelAttached">
            <summary>
            Returns true if at least one output channel is attached.
            </summary>
            <remarks>
            If the output channel is attached it means the object that has attached the channel
            can send messages.
            Multiple output channel attachable means that the object can send messages to more receivers.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels.AttachedOutputChannels">
            <summary>
            Returns attached output channels.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageSender`2">
            <summary>
            The interface declares the reliable sender that sends sequences of typed messages.
            The sender is able to send sequences of typed messages and receive sequences of typed response messages.
            In addition, the sender provides events notifying whether the message was delivered.
            The reliable typed sequenced message sender can be used only with reliable typed sequenced message receiver.
            </summary>
            <typeparam name="_ResponseType"></typeparam>
            <typeparam name="_RequestType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageSender`2.SendMessage(`1,System.String,System.Boolean)">
            <summary>
            Sends the message.
            </summary>
            <param name="message">message</param>
            <param name="sequenceId">identifies the sequence the message is part of</param>
            <param name="isSequenceCompleted">true - indicates the sequence is completed</param>
            <returns>message id</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageSender`2.ResponseReceived">
            <summary>
            The event is invoked when the response message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageSender`2.MessageDelivered">
            <summary>
            The event is invoked when the message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageSender`2.MessageNotDelivered">
            <summary>
            The event is invoked when the message was not delivered within the specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableInputChannel">
            <summary>
            The interface declares methods to attach/detach IReliableInputChannel
            </summary>
            <remarks>
            For more details about the reliable input channel see <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableInputChannel.AttachReliableInputChannel(Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel)">
            <summary>
            Attaches the reliable input channel and starts listening to messages.
            </summary>
            <param name="reliableInputChannel"></param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableInputChannel.DetachReliableInputChannel">
            <summary>
            Detaches the reliable input channel and stops listening to messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableInputChannel.IsReliableInputChannelAttached">
            <summary>
            Returns true if the reliable input channel is attached.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableInputChannel.AttachedReliableInputChannel">
            <summary>
            Returns attached reliable input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2">
            <summary>
            The interface declares the strongly typed reliable message receiver.
            The receiver is able to receive messages of the specified type and send back response messages of specified type.
            In addition it provides events notifying whether the respone message was delivered.
            The reliable typed message receiver can be used only with the reliable typed message sender.
            </summary>
            <typeparam name="_ResponseType"></typeparam>
            <typeparam name="_RequestType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.SendResponseMessage(System.String,`0)">
            <summary>
            Sends the typed response message.
            </summary>
            <param name="responseReceiverId">identifies the response receiver</param>
            <param name="responseMessage">respone message</param>
            <returns>id od the sent response message</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.MessageReceived">
            <summary>
            The event is invoked when the message is received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseReceiverConnected">
            <summary>
            The event is invoked when the reliable typed message sender opened connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the reliable typed message sender was disconnected.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseMessageDelivered">
            <summary>
            The event is invoked when the response message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseMessageNotDelivered">
            <summary>
            The event is invoked when the response message was not delivered within specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1">
            <summary>
            The class is used by the eneter framework to transfer command return data.
            </summary>
            <typeparam name="_ReturnDataType">type of return data from the command</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.#ctor">
            <summary>
            Default constructor for deserializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.#ctor(System.String,Eneter.Messaging.EndPoints.Commands.ECommandState,`0,System.String)">
            <summary>
            Constructs the class from the input parameters.
            </summary>
            <param name="commandId">command identifier</param>
            <param name="state">command state</param>
            <param name="returnData">return data</param>
            <param name="errorMessage">command identifier</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.CommandState">
            <summary>
            State of the command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.ReturnData">
            <summary>
            Return data.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.ErrorMessage">
            <summary>
            Error message from the command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.CommandId">
            <summary>
            Command identifier.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandInputData`1">
            <summary>
            The class is used by the eneter framework to transfer a request to the command.
            </summary>
            <typeparam name="_InputDataType">type of input data</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandInputData`1.#ctor">
            <summary>
            Default constructor for deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandInputData`1.#ctor(System.String,Eneter.Messaging.EndPoints.Commands.ECommandRequest,`0)">
            <summary>
            Constructs from the input parameters.
            </summary>
            <param name="commandId">command identifier</param>
            <param name="request">type of the request</param>
            <param name="inputData">input data</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandInputData`1.Request">
            <summary>
            Type of the request.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandInputData`1.InputData">
            <summary>
            Input data.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandInputData`1.CommandId">
            <summary>
            Command identifier.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Wrapping.DataWrapper">
            <summary>
            Implements the wrapper/unwrapper of data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Wrapping.DataWrapper.Wrap(System.Object,System.Object,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Adds the data to already serialized data.
            </summary>
            <remarks>
            It creates the <see cref="T:Eneter.Messaging.DataProcessing.Wrapping.WrappedData"/> from the given data and serializes it with the provided serializer.<br/>
            </remarks>
            <param name="addedData">Added data. It must a basic .Net type. Otherwise the serialization will fail.</param>
            <param name="originalData">Already serialized data - it is type of string or byte[].</param>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Wrapping.DataWrapper.Unwrap(System.Object,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Takes the serialized WrappedData and deserializes it with the given serializer.
            </summary>
            <param name="wrappedData">data serialized by 'Wrap' method</param>
            <param name="serializer">serializer</param>
            <returns>deserialized WrappedData</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.AesSerializer">
            <summary>
            Serializer using AES (Advanced Encryption Standard).
            </summary>
            <remarks>
            The serializer uses an underlying serializer to serialize and deserialize data.
            Data encoded by the underlying serializer is then encrypted by AES.
            <example>
            Encrypted serialization with <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>
            <code>
            // Create the serializer. The defualt constructor uses XmlStringSerializer.
            AesSerializer aSerializer = new AesSerializer("My password.");
            
            // Create some data to be serialized.
            MyData aData = new MyData();
            ...
            
            // Serialize data with using AES.
            object aSerializedData = aSerializer.Serialize&lt;MyData&gt;(aData);
            </code>
            </example>
            <br/><br/>
            Notice, since AesSerializer serializes into array of bytes, it is not possible to use this serializer
            for the communication between two Silverlight applications. The communication between two silverlight applications
            requires, that data is serialized into the string.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.ISerializer">
            <summary>
            The interface declares the API for serialization and deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.ISerializer.Serialize``1(``0)">
            <summary>
            Serializes data to object.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>
            Object representing the serialized data.
            Typically it can be byte[] or string.
            </returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.ISerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String)">
            <summary>
            Constructs the serializer. It uses <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/> as the underlying serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String,System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
            <param name="salt">additional value used to calculate the key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String,System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Int32)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate the key</param>
            <param name="salt">additional value used to calculate the key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
            <param name="keyBitSize">bit size of the key e.g. 128, 256</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Security.Cryptography.DeriveBytes,System.Int32)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
            <param name="passwordBasedKeyGenerator">generator of key from the password</param>
            <param name="keyBitSize">bit size of the key</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the object.
            The returned object is type of byte[]. Returned bytes are encrypted.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Encrypted data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer">
            <summary>
            Declares the load balancer.
            </summary>
            <remarks>
            The load balancer maintains a list of receivers processing a certain request.
            When the balancer receives the request, it chooses which receiver shall process it,
            so that all receivers are loaded optimally.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.AddDuplexOutputChannel(System.String)">
            <summary>
            Adds the request receiver to the load balancer.
            </summary>
            <param name="channelId">channel id (address) of the receiver processing requests.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.RemoveDuplexOutputChannel(System.String)">
            <summary>
            Removes the request receiver from the load balancer.
            </summary>
            <param name="channelId">channel id (address) of the receiver processing requests.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.RemoveAllDuplexOutputChannels">
            <summary>
            Removes all request receiers from the load balanacer.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.ResponseReceiverConnected">
            <summary>
            The event is invoked when the client sending requests was connected to the balancer.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the client sending requests was disconnected from the balanacer.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBroker">
            <summary>
            The interface declares the broker.
            The broker receives messages and forwards them to subscribed clients.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Bridge.IDuplexBridge">
             <summary>
             Declares the duplex bridge for request-response messaging.
             </summary>
             <remarks>
             The bridge allows to connect applications in case the receiving application uses some different
             mechanism for receiving messages.<br/>
             E.g. The ASP server uses message handlers (*.ashx files). Therefore, if the ASP server wants to receive
             messages from the Silverlight application, then the ASP server can use the bridge component to route messages
             received via the message handler.
             <br/>
             The duplex bridge can be used for the bidirectional communication. It can route both, requests and response messages.<br/>
             <br/>
             The bridging works like this:<br/>
             The Silverlight application sends the message via HTTP to the handler of ASP server.
             The ASP server receives the HTTP request in the handler. The implementation of the handler then uses the bridge and its method
             <see cref="M:Eneter.Messaging.Nodes.Bridge.IDuplexBridge.ProcessRequestResponse(System.IO.Stream,System.IO.Stream)"/> to process the request.
             <example>
             The following example shows an example how to implement the duplex bridge in the Asp Server.
             <code>
             // Handles messaging communication with Silverlight clients.
             public class MessagingHandler : IHttpHandler
             {
                 public void ProcessRequest(HttpContext context)
                 {
                     context.Application.Lock();
            
                     // Get the bridge from the context.
                     IDuplexBridge aBridge = context.Application["Bridge"] as IDuplexBridge;
                     
                     // Ask bridge to route the request and response messages.
                     aBridge.ProcessRequestResponse(context.Request.InputStream, context.Response.OutputStream);
            
                     context.Application.UnLock();
                 }
            
                 public bool IsReusable { get { return false; } }
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Bridge.IDuplexBridge.ProcessRequestResponse(System.IO.Stream,System.IO.Stream)">
            <summary>
            Processes the incoming request.
            </summary>
            <remarks>
            The method reads the "low-level" message from the requestMessage input parameter.<br/>
            If the message is 'poll request', then it reads collected response messages and writes them to the responseMessages input parameter.<br/>
            If the message is 'open connection request', then it opens the connection with the real receiver.<br/>
            If the message is 'close connection request', then it closes the connection with the real receiver.<br/>
            If the message is 'message request', then it forwards the message to the real receiver.<br/>
            <br/>
            The bridge also listens to response messages. If the response message is received, the message is stored until the poll request
            will not take it.
            </remarks>
            <param name="requestMessage">message comming as a request</param>
            <param name="responseMessages">messages returned as responses</param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transferring messages synchronously in the context of the caller thread.
            </summary>
            <remarks>
            This messaging system transfers messages synchronously in the context of the calling thread.
            Therefore the calling thread is blocked until the message is delivered and processed.
            However, the notification events (e.g. connection opened, ...) can come in a different thread.
            The messaging system is very fast and is suitable to deliver messages locally between internal communication components.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transferring messages via Named Pipes.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpRequestContext.GetRequestMessage">
            <summary>
            Returns the body content of the HTTP request.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpRequestContext.Response(System.Byte[])">
            <summary>
            Responses back to the HTTP client.
            </summary>
            <param name="message">body content.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpRequestContext.ResponseError(System.Int32)">
            <summary>
            Responses back the error.
            </summary>
            <param name="statusCode"></param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.VoidMessage">
            <summary>
            Represents an empty data type 'void'.
            Can be used with if no type is expected as a message.
            </summary>
            <remarks>
            <example>
            The following example shows how to use VoidMessage to declare a message sender
            sending string messages and receiving "nothing".
            <code>
            ...
            IDuplexTypedMessageSender&lt;VoidMessage, string&gt; myMessageSender;
            ...
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel">
            <summary>
            The interface declares methods to attach/detach one IOutputChannel.
            </summary>
            <remarks>
            The output channel is used in one-way communication by a sender to send messages.
            Components that are able to attach the output channel can send messages but they cannot receive any response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel.AttachOutputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel)">
            <summary>
            Attaches the output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel.DetachOutputChannel">
            <summary>
            Detaches the output channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel.IsOutputChannelAttached">
            <summary>
            Returns true if the output channel is attached.
            </summary>
            <remarks>
            If the output channel is attached it means the object that has attached the channel
            can send messages.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel.AttachedOutputChannel">
            <summary>
            Returns attached output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessageSender`1">
            <summary>
            The interface declares the strongly typed messsage sender.
            The sender is able to send messages of the specified type via one-way output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessageSender`1.SendMessage(`0)">
            <summary>
            Sends the message of specified type via IOutputChannel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageSender`1.SendMessage(`0)">
            <summary>
            Sends message via the output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2">
            <summary>
            The interface declares the strongly typed duplex message sender.
            The duplex sender is able to send messages of the specified type and receive responses of the specified type.
            </summary>
            <typeparam name="_ResponseType">The type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">The type of sending messages.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.SendRequestMessage(`1)">
            <summary>
            Sends the strongly typed message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.ResponseReceived">
            <summary>
            The event is invoked when a response message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageReceiver">
            <summary>
            The interface declares the reliable string message receiver.
            The reliable string message receiver can receiver string messages and response string messages.
            In addition it provides events notifying whether the response messages were delivered.
            The reliable string message receiver can be used only with the reliable string message sender.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageReceiver.SendResponseMessage(System.String,System.String)">
            <summary>
            Sends the response message back to the connected reliable string message sender.
            </summary>
            <param name="responseReceiverId">identifies the duplex string message sender that will receive the response</param>
            <param name="responseMessage">response message</param>
            <returns>id of the respones message</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageReceiver.RequestReceived">
            <summary>
            The event is invoked when the message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageReceiver.ResponseReceiverConnected">
            <summary>
            The event is invoked when a reliable string message sender opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageReceiver.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a reliable string message sender closed the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageReceiver.ResponseMessageDelivered">
            <summary>
            The event is invoked when the response message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageReceiver.ResponseMessageNotDelivered">
            <summary>
            The event is invoked when the respone message was not delivered within the specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ICommandContext`2">
            <summary>
            The interface represents the context of the particular command execution.
            It is passed as the input parameter to the method performing the command.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.DequeueInputData">
            <summary>
            Returns the input data for the command.
            The command proxy has a possibility to send the input data as a sequence. Therefore the input data coming in
            fragments are put to the queue, from where they can be removed by this method.
            If the queue is empty the calling thread is blocked until the input data fragment is received.<br/>
            Note: The parameter index in DataFragment is not used and is set to -1.
            </summary>
            <returns>data fragment wrapping the input data</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.DequeueInputData(System.Int32)">
            <summary>
            Returns the input data for the command.
            The command proxy has a possibility to send the input data as a sequence. Therefore the input data coming in
            fragments are put to the queue, from where they can be removed by this method.
            If the queue is empty the calling thread is blocked until
            the input data fragment is received or the specified timeout occured.
            Note: The parameter index in DataFragment is not used and is set to -1.
            </summary>
            <param name="millisecondsTimeout">maximum waiting time for the input data. If the time is exceeded the TimeoutException is thrown.</param>
            <returns>data fragment wrapping the input data</returns>
            <exception cref="T:System.TimeoutException">when the maximum waiting time for the input data is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.WaitIfPause">
            <summary>
            If the pause is the current request then it blocks the calling thread until resumed or canceled.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.WaitIfPause(System.Int32)">
            <summary>
            If the pause is requested then it blocks the calling thread until resumed or canceled.
            </summary>
            <param name="millisecondsTimeout">maximum waiting time in miliseconds</param>
            <returns>true if the timeout did not occur</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.ResponsePause">
            <summary>
            Notifies the command proxy that the command was paused.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.ResponseCancel">
            <summary>
            Notifies the command proxy that the command was canceled.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.ResponseFailure(System.String)">
            <summary>
            Notifies the command proxy that the command failed.
            </summary>
            <param name="errorMessage">error message</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.Response(Eneter.Messaging.EndPoints.Commands.ECommandState,`0)">
            <summary>
            Sends the return data to the command proxy.
            </summary>
            <param name="commandState">command state</param>
            <param name="returnData">return data</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.Response(Eneter.Messaging.EndPoints.Commands.ECommandState,`0,System.String,System.Boolean)">
            <summary>
            Sends the return data to the command proxy.
            The method can be used if the return data is sent in more fragments.
            E.g. If the command wants to notify progress or some partial results.
            </summary>
            <param name="commandState">command state</param>
            <param name="returnData">return data</param>
            <param name="sequenceId">identifies the sequence where the fragment of return data belongs</param>
            <param name="isReturnDataSequenceCompleted">true if this is the last fragment of the sequence</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.CommandProxyId">
            <summary>
            Returns identifier of the command proxy that executed this command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.CommandId">
            <summary>
            Returns identifier of this command. (If one command proxy executes more commands they can be recognized with this id.)
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.NumberOfInputData">
            <summary>
            Returns number of input data in the queue.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.CurrentRequest">
            <summary>
            The currently set request for the command e.g. Pause, Resume or Cancel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.IsCommandProxyConnected">
            <summary>
            Returns true if the command proxy that executed the command is still connected.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandReceivingErrorEventArgs">
            <summary>
            Event data when an error was detected during receiving a request in the command.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandReceivingErrorEventArgs.#ctor(System.String,System.Exception)">
            <summary>
            Constructs the event data.
            </summary>
            <param name="commandProxyId">identifier of the command proxy that sent the request</param>
            <param name="receivingError">error detected during receiving the request (e.g. deserialization error)</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandReceivingErrorEventArgs.ReceivingError">
            <summary>
            Gets error detected during receiving the request (e.g. deserialization error)
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.DynamicStream">
            <summary>
            Implements the stream that can be written and read at the same time.
            </summary>
            <remarks>
            The dynamic stream supports writing of data by one thread and reading by another.
            The reading operation is blocked until the requested amount of data is not available.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Flush">
            <summary>
            The Flush is not applicable. If called, it does nothing.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            The stream does not support Seek.
            It throws NotSupportedException.
            </summary>
            <param name="offset">not applicable</param>
            <param name="origin">not applicable</param>
            <returns>not applicable</returns>
            <exception cref="T:System.NotSupportedException">
            </exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.SetLength(System.Int64)">
            <summary>
            The stream does not support SetLength.
            It throws NotSupportedException.
            </summary>
            <param name="value">not applicable</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads data from the stream to the specified buffer.
            </summary>
            <remarks>
            If the requested amount of data is not available the thread is blocked until required amount of data
            is available - until data is written by another thread.
            </remarks>
            <param name="buffer">The buffer where the data will be written.</param>
            <param name="offset">Starting position in the buffer where data will be wqritten.</param>
            <param name="count">Requested amount of data to be read.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the data to the stream.
            </summary>
            <param name="buffer">Buffer to be written to the stream</param>
            <param name="offset">Starting podition in the buffer from where data will be read.</param>
            <param name="count">Amount of data to be read from the buffer and written to the stream.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Close">
            <summary>
            Closes the stream and releases the reading thread waiting for data.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.myMessageQueue">
            <summary>
            The writing puts the byte sequences to the queue as they come.
            The reading removes the sequences of bytes from the queue.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.IsBlockingMode">
            <summary>
            Gets or sets the blocking mode. If blocking mode then Read method blocks until data is available.
            </summary>
            <remarks>
            If blocking mode then Read method blocks until data is available. If unblocking mode is set then
            Read method reads available data and returns. If a reading thread is blocked (waiting) and the unblocking mode
            is set the thread is released.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanRead">
            <summary>
            Returns true, because the stream supports reading.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanSeek">
            <summary>
            Returns false, because the stream does not support Seek.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanWrite">
            <summary>
            Returns true, because the stream supports writing.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Length">
            <summary>
            Returns always 0.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Position">
            <summary>
            'Get' returns always 0. Set does nothing.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.MultiInstanceFragmentProcessor">
            <summary>
            Implements the fragment processor able to process more sequences of fragments in parallel.
            It creates the fragment processor (IFragmentProcessor) for each sequence.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.IMultiInstanceFragmentProcessor">
            <summary>
            The interface declares the fragment processor that is able to process more sequences in parallel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.IMultiInstanceFragmentProcessor.ProcessFragment(Eneter.Messaging.DataProcessing.Sequencing.IFragment)">
            <summary>
            Processes the fragment and returns the sequence of processed fragments ready for the user.
            If the processing of the fragment do not result in a sequence for the user it can return the empty sequence.<br/>
            
            E.g.: It can happen the fragments of the sequence do not come in the right order. Therefore the processing
                  can hold such fragments and return the empty sequence. Then later when it is possible to return
                  fragments in the correct order the processing can return the sequence with fragments.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IChannelUnwrapper">
            <summary>
            Declares the channel unwrapper.
            </summary>
            <remarks>
            The channel wrapper is listening to more input channels. When it receives some message,
            it wraps the message and sends it via the only output channel.
            On the other side the message is received by channel unwrapper. The unwrapper unwraps the message
            and uses the output channel to forward the message to the correct receiver.<br/>
            The message can be sent only one-way. For the bidirectional communication see <see cref="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelWrapper"/> and
            <see cref="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper"/>.<br/>
            Notice, the 'channel unwrapper' can communication only with 'channel wrapper'. It cannot communicate with 'duplex channel wrapper'.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel">
            <summary>
            The interface declares methods to attach/detach one IInputChannel.
            </summary>
            <remarks>
            The input channel is used in one-way communication by a listener to receive messages.
            Components that are able to attach the input channel can listen to messages but they cannot send back any response message.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel.AttachInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel)">
            <summary>
            Attaches the input channel.
            It stores the reference to the input channel and starts the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel.DetachInputChannel">
            <summary>
            Detaches the input channel.
            It cleans the reference to the input channel and stops the listening.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel.IsInputChannelAttached">
            <summary>
            Returns true if the reference to the input channel is stored. <br/>
            </summary>
            <remarks>
            Notice, unlike version 1.0, the true value does not mean the channel is listening.
            The method AttachInputChannel() starts also the listening, but if the listening stops (for whatever reason),
            the input channel stays attached. To figure out if the input channel is listening use property <see cref="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.IsListening"/>.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel.AttachedInputChannel">
            <summary>
            Returns attached input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient">
            <summary>
            Declares the broker client.
            </summary>
            <remarks>
            The broker client allows to send messages via the broker, so that broker will forward them to all subscribers.<br/>
            It also allows to subscribe for messages the client is interested to.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.SendMessage(System.String,System.Object)">
            <summary>
            Sends the notification message to the broker.
            </summary>
            <param name="eventId">identifies the event</param>
            <param name="serializedMessage">
            message content. If the message is not a primitive type or string then the input parameter expects the message is already serialized!
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Subscribe(System.String)">
            <summary>
            Subscribes the client for the message.
            </summary>
            <param name="eventId">event that shall be observed</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Subscribe(System.String[])">
            <summary>
            Subscribes the client for list of messages.
            </summary>
            <param name="eventIds">list of events that shall be observed</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.SubscribeRegExp(System.String)">
            <summary>
            Subscribes the client for message types matching with the given regular expression.
            </summary>
            <remarks>
            When a published message comes to the broker, the broker will check the message type id
            and will forward it to all subscribed clients.<br/>
            The broker will use the given regular expression to recognize whether the client is subscribed
            or not.<br/>
            The .NET based Broker internally uses Regex class to evaluate the regular expression.<br/>
            The Java based Broker internally uses Pattern class to evaluate the regular expression.<br/>
            Regular expressions between .NET and Java does not have to be fully compatible.
            
            <example>
            Few examples for subscribing via regular expression.
            <code>
            // Subscribing for message types starting with the string MyMsg.Speed
            myDuplexBrokerClient.SubscribeRegExp(@"^MyMsg\.Speed);
            
            // Subscribing for message types starting with MyMsg.Speed or App.Utilities
            myDuplexBrokerClient.SubscribeRegExp(@"^MyMsg\.Speed|^App\.Utilities");
            </code>
            </example>
            </remarks>
            <param name="regularExpression">
            Regular expression that will be evaluated by the broker to recognize whether the client is subscribed.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.SubscribeRegExp(System.String[])">
            <summary>
            Subscribes the client for message types matching with the given list of regular expressions.
            </summary>
            <remarks>
            When a published message comes to the broker, the broker will check the message type id
            and will forward it to all subscribed clients.<br/>
            The broker will use the given regular expression to recognize whether the client is subscribed
            or not.<br/>
            The .NET based Broker internally uses Regex class to evaluate the regular expression.<br/>
            The Java based Broker internally uses Pattern class to evaluate the regular expression.<br/>
            Regular expressions between .NET and Java does not have to be fully compatible.
            </remarks>
            <param name="regularExpressions">
            List of regular expressions that will be evaluated by the broker to recognize whether the client is subscribed.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe(System.String)">
            <summary>
            Unsubscribes the client from the specified message.
            </summary>
            <param name="eventId">event which shall not be observed anymore</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe(System.String[])">
            <summary>
            Unsubscribes the client from specified messages.
            </summary>
            <param name="eventIds">list of events that shall not be observed anymore</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.UnsubscribeRegExp(System.String)">
            <summary>
            Removes the regular expression subscription.
            </summary>
            <remarks>
            When the broker receives this request, it will search if the given regular expression string
            exists for the calling client. If yes, it will be removed.
            </remarks>
            <param name="regularExpression">Regular expression that was previously used for the subscription
            and now shall be removed.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.UnsubscribeRegExp(System.String[])">
            <summary>
            Removes all regular expression subscriptions.
            </summary>
            <remarks>
            When the broker receives this request, it will search if the given regular expression strings
            exist for the calling client. If yes, they will be removed.
            </remarks>
            <param name="regularExpressions"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe">
            <summary>
            Completely unsubscribes the client from all messages (including all regular expressions).
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.BrokerMessageReceived">
            <summary>
            The event is invoked when the observed message is received from the broker.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext">
            <summary>
            Represents the client context on the server side.
            </summary>
            <remarks>
            The client context is obtained when a client opened the connection with the server and
            it provides functionality to receive messages from the client and send back response messages.
            <br/>
            To see the example refer to <see cref="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener"/>.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.SendMessage(System.Object)">
            <summary>
            Sends message to the client.
            </summary>
            <remarks>
            The message must be type of string or byte[]. If the type is string then the message is sent as the text message via text frame.
            If the type is byte[] the message is sent as the binary message via binary frame.
            </remarks>
            <param name="data">message to be sent to the client. Must be byte[] or string.</param>
            <exception cref="T:System.ArgumentException">input parameter is not string or byte[].</exception>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.SendMessage(System.Object,System.Boolean)">
            <summary>
            Sends message to the client. Allows to send the message via multiple frames.
            </summary>
            <remarks>
            The message must be type of string or byte[]. If the type is string then the message is sent as the text message via text frame.
            If the type is byte[] the message is sent as the binary message via binary frame.<br/>
            <br/>
            It allows to send the message in multiple frames. The client then can receive all parts separately
                
            <example>
            The following example shows how to send 'Hello world.' in three parts.
            <code>
            void ProcessConnection(IWebSocketClientContext clientContext)
            {
                ...
                
                // Send the first part of the message.
                clientContext.SendMessage("Hello ", false);
                
                // Send the second part.
                clientContext.SendMessage("wo", false);
                
                // Send the third final part.
                clientContext.SendMessage("rld.", true);
                
                ...
            }
            </code>
            </example>
            </remarks>
            <param name="data">message to be sent to the client. The message can be byte[] or string.</param>
            <param name="isFinal">true if this is the last part of the message.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.ReceiveMessage">
            <summary>
            Waits until a message is received from the client.
            </summary>
            <remarks>
            <example>
            Example shows how to implement a loop receiving the text messages from the client.
            <code>
            void ProcessConnection(IWebSocketClientContext clientContext)
            {
                // The loop waiting for incoming messages.
                // Note: The waiting thread is released when the connection is closed.
                WebSocketMessage aWebSocketMessage;
                while ((aWebSocketMessage = clientContext.ReceiveMessage()) != null)
                {
                    if (aWebSocketMessage.IsText)
                    {
                        // Wait until all data frames are collected
                        // and return the message.
                        string aMessage = aWebSocketMessage.GetWholeTextMessage();
                        ...
                    }
                }
            }
            </code>
            </example>
            </remarks>
            <returns>message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.SendPing">
            <summary>
            Pings the client. According to websocket protocol, pong should be responded.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.SendPong">
            <summary>
            Sends unsolicited pong to the client.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.CloseConnection">
            <summary>
            Closes connection with the client.
            </summary>
            <remarks>
            It sends the close message to the client and closes the underlying tcp connection.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.ConnectionClosed">
            <summary>
            The event is invoked when the connection with the client was closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.PongReceived">
            <summary>
            The event is invoked when the pong message was received.
            </summary>
            <remarks>
            The pong message is sent as a response to ping. According to websocket protocol
            unsolicit pong can be sent too. (i.e. it does not have to be a response to a ping)<br/>
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.ClientEndPoint">
            <summary>
            Returns the IP address of the connected client.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.IsConnected">
            <summary>
            Returns true if the client is connected.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.Uri">
            <summary>
            Returns URI of this connection including query parameters sent from by the client.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.HeaderFields">
            <summary>
            Returns the readonly dictionary containing header HTTP header fields.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory">
            <summary>
            The factory class creating the security stream allowing authentication as server and encrypted communication
            based on SSL protocol.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory">
            <summary>
            Declares the factory responsible for creating the security stream.
            </summary>
            <remarks>
            The security stream wrapps the source stream and provides functionality for authentication (verifying communicating parts),
            encryption (writes encrypted data to the wrapped stream) and decryption (decrypts data from the wrapped stream).
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory.CreateSecurityStreamAndAuthenticate(System.IO.Stream)">
            <summary>
            Creates the security stream and performs the authentication.
            </summary>
            <param name="source">The stream wrapped by the security stream.</param>
            <returns>Security stream.</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="certificate">Server certificate.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="certificate">Server certificate.</param>
            <param name="isClientCertificateRequired">true - if the client identity is verified too.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="certificate">Server certificate.</param>
            <param name="isClientCertificateRequired">true - if the client identity is verified too.</param>
            <param name="userCertificateValidationCallback">User provided delegate for validating the certificate supplied by the remote party.</param>
            <param name="userCertificateSelectionCallback">User provided delegate for selecting the certificate used for authentication.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory.CreateSecurityStreamAndAuthenticate(System.IO.Stream)">
            <summary>
            Creates the security stream and performs the authentication as client.
            </summary>
            <param name="source">The stream wrapped by the security stream.</param>
            <returns>Security stream of type SslStream.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientNegotiateFactory">
            <summary>
            The factory class creating the security stream allowing the authentication and encrypted communication
            based on 'Negotiate communication protocol'.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientNegotiateFactory.#ctor">
            <summary>
            Constructs the factory that will use client's default credentials and the service principal name will not be specified.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientNegotiateFactory.#ctor(System.Net.NetworkCredential,System.String)">
            <summary>
            Constructs the factory that will use the specified user credentials and specified service principal name.
            </summary>
            <param name="networkCredential">identity of the client</param>
            <param name="servicePrincipalName">service principal name that uniquely identifies the server to authenticate</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientNegotiateFactory.CreateSecurityStreamAndAuthenticate(System.IO.Stream)">
            <summary>
            Creates security stream and authenticates as client.
            </summary>
            <param name="source">The stream wrapped by the security stream.</param>
            <returns>Security stream of type NegotiateStream.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider">
            <summary>
            The interface declares the default functionality to send and receive messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.SendMessage(System.String,System.Object)">
            <summary>
            Sends the message to desired receiver.
            </summary>
            <param name="receiverId"></param>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.RegisterMessageHandler(System.String,System.Action{System.Object})">
            <summary>
            Registers the method handling the message.
            </summary>
            <param name="receiverId"></param>
            <param name="messageHandler"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.UnregisterMessageHandler(System.String)">
            <summary>
            Unregisters the handler.
            </summary>
            <param name="receiverId"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory">
            <summary>
            Implements the messaging system delivering messages via HTTP.
            </summary>
            <remarks>
            It creates the communication channels using HTTP for sending and receiving messages.
            The channel id must be a valid URI address. E.g.: http://127.0.0.1/something/ or https://127.0.0.1/something/. <br/>
            Because HTTP is request-response based protocol, it does not keep the connection open.
            Therefore, for the bidirectional communication used by duplex channels, the polling mechanism is used.
            The duplex output channel regularly polls for response messages and the duplex input channel constantly measures the inactivity time
            to recognize whether the duplex output channel is still connected.<br/><br/>
            Notice, to start listening via input channel (or duplex input channel), the application must be executed with sufficient rights.
            Otherwise the exception will be thrown.<br/>
            Also notice, Silverlight and Windows Phone 7 do not support listening to HTTP requests.
            Therefore, only sending of messages (and receiving response messages) is possible in these platforms.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory that will create channels with default settings. The polling
            frequency will be 500 ms and the inactivity timeout will be 10 minutes.
            </summary>
            <remarks>
            The polling frequency and the inactivity time are used only by duplex channels.
            The polling frequency specifies how often the duplex output channel checks if there are pending response messages.
            The inactivity time is measured by the duplex input channel and specifies the maximum time, the duplex output channel
            does not have to poll for messages.
            If the inactivity time is exceeded, considers the duplex output channel as disconnected.
            <br/><br/>
            In case of Silverlight or Windows Phone 7, the response messages are recieved in the main Silverlight thread.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs the factory that will create channel with specified settings.
            </summary>
            <remarks>
            The polling frequency and the inactivity time are used only by duplex channels.
            The polling frequency specifies how often the duplex output channel checks if there are pending response messages.
            The inactivity time is measured by the duplex input channel and specifies the maximum time, the duplex output channel
            does not have to poll for messages.
            If the inactivity time is exceeded, considers the duplex output channel as disconnected.
            </remarks>
            <param name="pollingFrequency">how often the duplex output channel polls for the pending response messages</param>
            <param name="inactivityTimeout">maximum time (measured by duplex input channel), the duplex output channel does not have to poll
            for response messages. If the time is exceeded, the duplex output channel is considered as disconnected.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor(System.Int32,System.Int32,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter{System.Byte[]})">
            <summary>
            Constructs the factory that will create channel with specified settings.
            </summary>
            <remarks>
            The polling frequency and the inactivity time are used only by duplex channels.
            The polling frequency specifies how often the duplex output channel checks if there are pending response messages.
            The inactivity time is measured by the duplex input channel and specifies the maximum time, the duplex output channel
            does not have to poll for messages.
            If the inactivity time is exceeded, considers the duplex output channel as disconnected.
            </remarks>
            <param name="pollingFrequency">how often the duplex output channel polls for the pending response messages</param>
            <param name="inactivityTimeout">maximum time (measured by duplex input channel), the duplex output channel does not have to poll
            for response messages. If the time is exceeded, the duplex output channel is considered as disconnected.</param>
            <param name="protocolFormatter">formatter for low-level messages between duplex output channel and duplex input channel</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to specified input channel by using HTTP.
            </summary>
            <remarks>
            The output channel can send messages only to the input channel and not to the duplex input channel.
            </remarks>
            <param name="channelId">Identifies the receiving input channel. The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/ </param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving message from the output channel using HTTP.
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/ .
            The method is not supported in Silverlight and Windows Phone 7.
            </summary>
            <remarks>
            The input channel can receive messages only from the output channel and not from the duplex output channel.
            </remarks>
            <param name="channelId">valid URI address, the input channel will listen to</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using HTTP.
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid address of the receiver. e.g. 127.0.0.1:8090</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using HTTP.
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid address of the receiver. e.g. 127.0.0.1:8090</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using HTTP.
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/
            The method is not supported in Silverlight and Windows Phone 7.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">channel id specifying the address the duplex input channel listens to.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.myPollingFrequency">
            <summary>
            Defines how often the client poll the server for response messages.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.myConnectedDuplexOutputChannelInactivityTimeout">
            <summary>
            Defines the time, that if the client does not connect the server, the client is considered as disconnected.
            10 minutes by default.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedMessageFragment`1">
            <summary>
            The message fragment for the specified message type.
            The message fragment wrapps the specified message type so that it can be sent as a part of a sequence.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.Fragment">
            <summary>
            Provides the basic implementation for IFragment.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.IFragment">
            <summary>
            The interface declares the fragment.
            Fragments are used to sequence data.
            The fragment contains the SequenceId identifying the sequence where the fragment blongs, Index specifying the position in the sequence
            and IsFinal indicating if it is the last fragment of the sequence.<br/>
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.IFragment.SequenceId">
            <summary>
            Returns identifier of the sequence where the fragment belongs.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.IFragment.Index">
            <summary>
            Returns the position of the fragment in the sequence.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.IFragment.IsFinal">
            <summary>
            Returns true if it is the last fragment in the sequence.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.Fragment.#ctor">
            <summary>
            Default constructor used for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.Fragment.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>
            Constructs the fragment from the input parameters.
            </summary>
            <param name="sequenceId">Identifies the sequence where the fragment belongs.</param>
            <param name="index">Position in the sequence.</param>
            <param name="isFinal">Indicates whether it is the last fragment.</param>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.Fragment.SequenceId">
            <summary>
            Returns the sequence identifier.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.Fragment.Index">
            <summary>
            Returns the position of the fragment in the sequence.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.Fragment.IsFinal">
            <summary>
            Returns true if the item is the last in the sequence.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedMessageFragment`1.#ctor">
            <summary>
            Default constructor for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedMessageFragment`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>
            Constructor creating the typed message fragment from the given input parameters.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedMessageFragment`1.FragmentData">
            <summary>
            Returns serialized fragment value.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessagesFactory">
            <summary>
            The interface declares the factory to create reliable typed sequenced message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessagesFactory.CreateReliableTypedSequencedMessageSender``2">
            <summary>
            Creates the reliable typed sequenced message sender.
            </summary>
            <typeparam name="_ResponseType">type of response message</typeparam>
            <typeparam name="_RequestType">type of request message</typeparam>
            <returns>reliable typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessagesFactory.CreateReliableTypedSequencedMessageReceiver``2">
            <summary>
            reliable typed sequenced message receiver.
            </summary>
            <typeparam name="_ResponseType">type of response message</typeparam>
            <typeparam name="_RequestType">type of request message</typeparam>
            <returns>reliable typed sequenced message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedMessagesFactory">
            <summary>
            Implements the factory to create strongly typed message senders and receivers.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessagesFactory">
            <summary>
            The interface declares the factory to create strongly typed message senders and receivers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessagesFactory.CreateTypedMessageSender``1">
            <summary>
            Creates the typed message sender.
            The sender sends the messages via attached one-way output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessagesFactory.CreateTypedMessageReceiver``1">
            <summary>
            Creates the typed message receiver.
            The receiver receives messages via attached one-way input channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessagesFactory.#ctor">
            <summary>
            Constructs the typed messages factory with BinarySerializer.
            <br/>
            <b>Note: The serializer is XmlStringSerializer in case of Silverlight.</b> 
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the typed message factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessagesFactory.CreateTypedMessageSender``1">
            <summary>
            Creates the typed message sender.
            The sender sends the messages via attached one-way output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessagesFactory.CreateTypedMessageReceiver``1">
            <summary>
            Creates the typed message receiver.
            The receiver receives messages via attached one-way input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory">
            <summary>
            Implements the factory to create duplex string message sender and receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory">
            <summary>
            The interface declares the factory to create duplex string message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory.CreateDuplexStringMessageSender">
            <summary>
            Creates the duplex string message sender.
            </summary>
            <returns>duplex string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory.CreateDuplexStringMessageReceiver">
            <summary>
            Creates the duplex string message receiver.
            </summary>
            <returns>duplex string message receiver</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory.CreateDuplexStringMessageSender">
            <summary>
            Creates the duplex string message sender.
            </summary>
            <returns>duplex string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory.CreateDuplexStringMessageReceiver">
            <summary>
            Creates the duplex string message receiver.
            </summary>
            <returns>duplex string message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2">
            <summary>
            The interface represents the context of the particular command execution.
            It is passed as the input parameter to the method performing the command.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.DequeueInputData">
            <summary>
            Returns the input data for the command.
            The command proxy has a possibility to send the input data as a sequence. Therefore the input data coming in
            fragments are put to the queue, from where they can be removed by this method.
            If the queue is empty the calling thread is blocked until the input data fragment is received.<br/>
            Note: The parameter index in DataFragment is not used and is set to -1.
            </summary>
            <returns>data fragment wrapping the input data</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.DequeueInputData(System.Int32)">
            <summary>
            Returns the input data for the command.
            The command proxy has a possibility to send the input data as a sequence. Therefore the input data coming in
            fragments are put to the queue, from where they can be removed by this method.
            If the queue is empty the calling thread is blocked until
            the input data fragment is received or the specified timeout occured.
            Note: The parameter index in DataFragment is not used and is set to -1.
            </summary>
            <param name="millisecondsTimeout">maximum waiting time for the input data. If the time is exceeded the TimeoutException is thrown.</param>
            <returns>data fragment wrapping the input data</returns>
            <exception cref="T:System.TimeoutException">when the maximum waiting time for the input data is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.WaitIfPause">
            <summary>
            If the pause is the current request then it blocks the calling thread until resumed or canceled.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.WaitIfPause(System.Int32)">
            <summary>
            If the pause is requested then it blocks the calling thread until resumed or canceled.
            </summary>
            <param name="millisecondsTimeout">maximum waiting time in miliseconds</param>
            <returns>true if the timeout did not occur</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.ResponsePause">
            <summary>
            Notifies the command proxy that the command was paused.
            </summary>
            <returns>Id of the response message.</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.ResponseCancel">
            <summary>
            Notifies the command proxy that the command was canceled.
            </summary>
            <returns>Id of the response message.</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.ResponseFailure(System.String)">
            <summary>
            Notifies the command proxy that the command failed.
            </summary>
            <param name="errorMessage">error message</param>
            <returns>Id of the response message.</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.Response(Eneter.Messaging.EndPoints.Commands.ECommandState,`0)">
            <summary>
            Sends the return data to the command proxy.
            </summary>
            <param name="commandState">command state</param>
            <param name="returnData">return data</param>
            <returns>Id of the response message.</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.Response(Eneter.Messaging.EndPoints.Commands.ECommandState,`0,System.String,System.Boolean)">
            <summary>
            Sends the return data to the command proxy.
            The method can be used if the return data is sent in more fragments.
            E.g. If the command wants to notify progress or some partial results.
            </summary>
            <param name="commandState">command state</param>
            <param name="returnData">return data</param>
            <param name="sequenceId">identifies the sequence where the fragment of return data belongs</param>
            <param name="isReturnDataSequenceCompleted">true if this is the last fragment of the sequence</param>
            <returns>Id of the response message.</returns>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.CommandProxyId">
            <summary>
            Returns identifier of the command proxy that executed this command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.CommandId">
            <summary>
            Returns identifier of this command. (If one command proxy executes more commands, then they can be recognized with this id.)
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.NumberOfInputData">
            <summary>
            Returns number of input data in the queue.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.CurrentRequest">
            <summary>
            The currently set request for the command e.g. Pause, Resume or Cancel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.IsCommandProxyConnected">
            <summary>
            Returns true if the command proxy that executed the command is still connected.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ICommand`2">
            <summary>
            The interface declares the reliable command.
            The command is able to receive typed request messages and return typed response messages.
            The command can be paused, resumed or canceled.
            </summary>
            <typeparam name="_ReturnDataType">Type of return data.</typeparam>
            <typeparam name="_InputDataType">Type of input data.</typeparam>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.ICommand`2.ErrorReceived">
            <summary>
            The event is invoked when an error was detected during receiving the request. (e.g. a deserialization error)
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.ICommand`2.CommandProxyConnected">
            <summary>
            The event is invoked when the command proxy was connected to the command.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.ICommand`2.CommandProxyDisconnected">
            <summary>
            The event is invoked when the command proxy disconnected from the command.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.Command`2.AttachDuplexInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel and starts listening.
            </summary>
            <param name="duplexInputChannel"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.Command`2.DetachDuplexInputChannel">
            <summary>
            Detaches the duplex input channel and stops the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.Command`2.OnMessageReceived(System.Object,Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs{Eneter.Messaging.EndPoints.Commands.CommandInputData{`1}})">
            <summary>
            The method is called when a request is received.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.Command`2.CommandProcessingAsyncCallback(System.IAsyncResult)">
            <summary>
            The method is called when the asynchronous call to process the command is finished.
            (in case of parallel processing mode)
            </summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.Command`2.WorkingThreadHandler(Eneter.Messaging.EndPoints.Commands.CommandItem{`0,`1})">
            <summary>
            Removes the 'execute command' requests from the queue and execute them.
            The method is used in case of single thread mode.
            </summary>
            <param name="commandContext"></param>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.EneterTrace">
            <summary>
            Implements the functionality for tracing messages.
            </summary>
            <remarks>
            The EneterTrace allows to trace error messages, warning message, info messages and debug messages.
            It also allows to trace entering and leaving from a method and measures the time spent in the method.
            In order to trace entering - leaving and debug messages, you must set the detail level to 'Debug'.<br/>
            <br/>
            Notice: The trace does not display namespaces and method names in Compact Framework platform.
            <example>
            Tracing entering and leaving and a warning message.
            <code>
            private class MyClass
            {
                private void MyMethod()
                {
                    // Tracing entering and leaving the method.
                    // Note: The entering-leaving is traced only if detail level is 'Debug'.
                    using (EneterTrace.Entering())
                    {
                        ... method implementation ...
                        
                        // Tracing a warning message.
                        EneterTrace.Warning("This is a warning message.");
                        
                        ...
                    }
                }
            }
            
            The output:
            11:59:11.365 ~008 --> YourNameSpace.MyClass.MyMethod
            11:59:11.704 ~008  W: YourNameSpace.MyClass.MyMethod This is a warning message.
            11:59:12.371 ~008 &lt;--  YourNameSpace.MyClass.MyMethod [00:00:01 000ms 969.0us]
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Entering">
            <summary>
            Traces entering-leaving the method.
            </summary>
            <remarks>
            The enetering information for the method calling this constructor is put to the trace
            and the measuring of the time starts.
            In order to trace entering-leaving, the detail level must be set to 'Debug'.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.System#IDisposable#Dispose">
            <summary>
            Traces the leaving from the method including the duration time.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Info(System.String)">
            <summary>
            Traces the info message.
            </summary>
            <param name="message">info message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Info(System.String,System.String)">
            <summary>
            Traces the information message.
            </summary>
            <param name="message">info message</param>
            <param name="details">additional details</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Info(System.String,System.Exception)">
            <summary>
            Traces the info message.
            </summary>
            <param name="message">info message</param>
            <param name="err">exception that will be traced</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Warning(System.String)">
            <summary>
            Traces warning message.
            </summary>
            <param name="message">warning message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Warning(System.String,System.String)">
            <summary>
            Traces the warning message.
            </summary>
            <param name="message">warning message</param>
            <param name="details">additional details</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Warning(System.String,System.Exception)">
            <summary>
            Traces the warning message.
            </summary>
            <param name="message">warning message</param>
            <param name="err">exception that will be traced</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Error(System.String)">
            <summary>
            Traces the error message.
            </summary>
            <param name="message">error message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Error(System.String,System.String)">
            <summary>
            Traces the error message and details for the error.
            </summary>
            <param name="message">error message</param>
            <param name="errorDetails">error details</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Error(System.String,System.Exception)">
            <summary>
            Traces the error message.
            </summary>
            <param name="message">error message</param>
            <param name="err">exception that will be traced</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Debug(System.String)">
            <summary>
            Traces the debug message.
            </summary>
            <remarks>
            To trace debug messages, the detail level must be set to debug.
            </remarks>
            <param name="message">error message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.EnqueueTraceMessage(System.String)">
            <summary>
            Puts the trace to the queue.
            </summary>
            <remarks>
            The queueing of traces ensures, the messages are traced in the correct order
            and the writing of the message does not consume traces - it would significantly affect the performance.
            </remarks>
            <param name="traceMessage"></param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.DoTracing(System.Object)">
            <summary>
            Removes traces from the queue and writes them.
            </summary>
            <remarks>
            The method is executed from a different thread.
            The thread then loops until the queue is processed.
            </remarks>
            <param name="x"></param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.#ctor">
            <summary>
            Private helper constructor.
            </summary>
            <remarks>
            The constructor is private, so the class can be enstantiating only via the 'Entering' method.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Diagnostic.EneterTrace.TraceLog">
            <summary>
            Sets or gets the user defined trace.
            </summary>
            <remarks>
            If the value is set, the trace messages are written to the specified trace and to the debug port.
            If the value is null, then messages are written only to the debug port.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Diagnostic.EneterTrace.DetailLevel">
            <summary>
            Sets or gets the detail level of the trace.
            </summary>
            <remarks>
            If the detail level is set to 'Short' then only info, warning and error messages are traced.<br/>
            If the detail level is set to 'Debug' then all messages are traced.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Diagnostic.EneterTrace.NameSpaceFilter">
            <summary>
            Sets or gets the regular expression that will be applied to the namespace to filter traced messages.
            </summary>
            <remarks>
            Sets or gets the regular expression that will be applied to the name space of the traced message.
            If the namespace matches with the regular expression, the message will be traced.
            If the filter is set to null, then the filter is not used and all messages will be traced.
            <example>
            The following example shows how to set the filter to trace a certain namespace.
            <code>
            // Set the debug detailed level.
            EneterTrace.DetailLevel = EneterTrace.EDetailLevel.Debug;
            
            // Examples:
            // Traces all name spaces starting with 'My.NameSpace'.
            EneterTrace.NameSpaceFilter = new Regex(@"^My\.NameSpace");
            
            // Traces exactly the name space 'My.NameSpace'.
            EneterTrace.NameSpaceFilter = new Regex(@"^My\.NameSpace$");
            
            // Traces name spaces starting with 'Calc.Methods' or 'App.Utilities'.
            EneterTrace.NameSpaceFilter = new Regex(@"^Calc\.Methods|^App\.Utilities");
            
            // Traces all name spaces except namespaces starting with 'Eneter'.
            EneterTrace.NameSpaceFilter = new Regex(@"^(?!\bEneter\b)");
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel">
            <summary>
            Detail level of the trace.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel.None">
            <summary>
            Messages are not traced.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel.Short">
            <summary>
            Info, Warning and Error messages.<br/>
            The debug messages and entering-leaving messages are not traced.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel.Debug">
            <summary>
            All messages are traced.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer">
            <summary>
            The class collects and sorts incoming fragments.
            When all fragments are collected the ProcessFragment method returns the fragment of sorted fragments.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.#ctor(System.String)">
            <summary>
            The constructor initializes the finalizer for the given instance id.
            </summary>
            <param name="sequenceId">sequence that the finalizer processes</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.ProcessFragment(Eneter.Messaging.DataProcessing.Sequencing.IFragment)">
            <summary>
            The method puts incoming fragment to the sequenece.
            It returns the collection when all fragments are collected and sorted.
            </summary>
            <param name="fragment"></param>
            <returns></returns>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.mySortedFragments">
            <summary>
            The collection collects ordered fragments.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.SequenceId">
            <summary>
            Returns the instance id.
            The instance id specifies which fragments belong together.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.IsWholeSequenceProcessed">
            <summary>
            Returns true if all fragments have been processed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.FragmentSequencer">
            <summary>
            The sequencer for sequencing of fragments.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerNegotiateFactory">
            <summary>
            The factory class creating the security stream allowing authentication as server and encrypted communication
            based on 'Negotiate communication protocol'.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerNegotiateFactory.CreateSecurityStreamAndAuthenticate(System.IO.Stream)">
            <summary>
            Creates security stream and authenticates as server.
            </summary>
            <param name="source">The stream wrapped by the security stream.</param>
            <returns>Security stream of type NegotiateStream.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transferring messages via shared memory. (Faster than Named Pipes.)
            </summary>
            <remarks>
            It transfers messages between processes running on the same machine using shared memory.
            Transferring messages via the shared memory is faster than using Named Pipes.<br/>
            Messaging via the shared memeory is supported only in .Net 4.0 or higher.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory">
            <summary>
            Implements the messaging system delivering messages via the shared memory.
            </summary>
            <remarks>
            It creates communication channels for sending and receiving messages via shared memory.<br/>
            Communication via the shared memory can transfer messages between applications running on the same machine
            and is significantly faster than using named pipes.<br/>
            Messaging via the shared memeory is supported only in .Net 4.0 or higher.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.#ctor">
            <summary>
            Constructs the messaging factory with the default settings.
            </summary>
            <remarks>
            The default constructor creates the factory that will create input and output channels
            using the shared memory. <br/>
            The maximum message size will be 10Mb.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.#ctor(System.Int32)">
            <summary>
            Constructs the messaging system with possibility to specify the maximum message size.
            </summary>
            <param name="maxMessageSize">maximum message size in bytes</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.#ctor(System.Int32,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter{System.Byte[]})">
            <summary>
            Constructs the messaging system.
            </summary>
            <param name="maxMessageSize">maximum message size in bytes</param>
            <param name="protocolFormatter">formatter used to encode low-level messages between channels</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to specified input channel via the shared memory.
            </summary>
            <remarks>
            The output channel can send messages only to the input channel and not to the duplex input channel.
            </remarks>
            <param name="channelId">Identifies the receiving input channel.
            The id is the name of the memory-mapped file that
            is used to send and receive messages.
            </param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving message from the output channel via the shared memory.
            </summary>
            <remarks>
            The input channel can receive messages only from the output channel and not from the duplex output channel.
            </remarks>
            <param name="channelId">
            Identifier of the listening input channel. The id is the name of the memory-mapped file that
            will be used to send and receive messages.
            </param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages
            via shared memory.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.
            The id is the name of the memory-mapped file that
            is used to send and receive messages.
            </param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages
            via shared memory.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.
            The id is the name of the memory-mapped file that
            is used to send and receive messages.
            </param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages
            via the shared memory.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">Identifier of the listening input channel. The id is the name of the memory-mapped file that
            will be used to send and receive messages.
            </param>
            <returns>duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs">
            <summary>
            Event argument containing parameters of the communication.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructs the event argument.
            </summary>
            <param name="channelId">Identifies the receiver of request messages. (e.g. tcp://127.0.0.1:8090/)</param>
            <param name="responseReceiverId">Unique logical id identifying the receiver of response messages.</param>
            <param name="senderAddress">Address where the sender of the request message is located. (e.g. IP address of the client)<br/>
            Can be empty string if not applicable in used messaging.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.ChannelId">
            <summary>
            Returns the channel id identifying the receiver of request messages. (e.g. tcp://127.0.0.1:8090/).
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.ResponseReceiverId">
            <summary>
            Returns the unique logical id identifying the receiver of response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.SenderAddress">
            <summary>
            Returns the address where the sender of the request message is located. (e.g. IP address of the client).
            It can be empty string if not applicable for used messaging.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs">
            <summary>
            The event data available when the input channel receives a message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs.#ctor(System.String,System.Object,System.String)">
            <summary>
            Constructs the event data from the input parameters.
            </summary>
            <param name="channelId">Identifies the receiver of messages. (e.g. tcp://127.0.0.1:8090/)</param>
            <param name="message">message</param>
            <param name="senderAddress">Address where the sender of the message is located. (e.g. IP address of the client)<br/>
            Can be empty string if not applicable in used messaging.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs.ChannelId">
            <summary>
            Returns the channel id identifying the receiver of messages. (e.g. tcp://127.0.0.1:8090/).
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs.Message">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs.SenderAddress">
            <summary>
            Returns the address where the sender of the message is located. (e.g. IP address of the client).
            It can be empty string if not applicable for used messaging.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageReceiver`2">
            <summary>
            The interface declares the reliable receiver for sequence of typed messages.
            The receiver is able to receive sequence of messages of specified type and response the sequence of messages
            of specified type. <br/>
            It is guaranteed the sequence is received in the same order as was sent. <br/>
            In addition, the reliable typed sequenced message reciever provides events notifying whether the response message was delivered.
            The reliable typed sequenced message reciever can be used only with the reliable typed sequenced message sender.
            <br/>
            <b>Note: Be aware that if the 'thread pool messaging system' is chosen the incoming messages
            are processed in more threads in parallel. Therefore the 'thread pool messaging system'
            cannot guarantee the order of incoming messages.</b> <br/>
            Consider to use the 'thread messaging system' instead.
            </summary>
            <typeparam name="_ResponseType"></typeparam>
            <typeparam name="_RequestType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageReceiver`2.SendResponseMessage(System.String,`0,System.String,System.Boolean)">
            <summary>
            Sends the response message.
            </summary>
            <param name="responseReceiverId">identifies the response receiver</param>
            <param name="responseMessage">message</param>
            <param name="sequenceId">identifies the sequence the message is part of</param>
            <param name="isSequenceCompleted">true - indicates the sequence is completed</param>
            <returns>message id</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageReceiver`2.MessageReceived">
            <summary>
            The event is invoked when the message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageReceiver`2.ResponseReceiverConnected">
            <summary>
            The event is invoked when the reliable typed sequenced message sender opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageReceiver`2.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the reliable typed sequenced message sender closed the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageReceiver`2.ResponseMessageDelivered">
            <summary>
            The event is invoked when the respponse message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageReceiver`2.ResponseMessageNotDelivered">
            <summary>
            The event is invoked when the response message is not delivered within specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory">
            <summary>
            Implements the factory to create duplex strongly typed message sender and receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory">
            <summary>
            The interface declares the factory to create duplex strongly typed message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory.CreateDuplexTypedMessageSender``2">
            <summary>
            Creates duplex typed message sender.
            </summary>
            <typeparam name="_ResponseType">Type of response messages.</typeparam>
            <typeparam name="_RequestType">Type of request messages.</typeparam>
            <returns>duplex typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory.CreateDuplexTypedMessageReceiver``2">
            <summary>
            Creates duplex typed message receiver.
            </summary>
            <typeparam name="_ResponseType">Type of response messages.</typeparam>
            <typeparam name="_RequestType">Type of receiving messages.</typeparam>
            <returns>duplex typed message receiver</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with xml serializer. <br/>
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the method factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.CreateDuplexTypedMessageSender``2">
            <summary>
            Creates duplex typed message sender.
            </summary>
            <typeparam name="_ResponseType">Type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">Type of sending messages.</typeparam>
            <returns>duplex typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.CreateDuplexTypedMessageReceiver``2">
            <summary>
            Creates duplex typed message receiver.
            </summary>
            <typeparam name="_ResponseType">Type of response messages.</typeparam>
            <typeparam name="_RequestType">Type of receiving messages.</typeparam>
            <returns>duplex typed message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender">
            <summary>
            The interface declares the duplex string message sender.
            The duplex sender is able to send text messages and receive text responses.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.SendMessage(System.String)">
            <summary>
            Sends the message via the attached duplex output channel.
            </summary>
            <param name="message">message</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.ResponseReceived">
            <summary>
            The event is invoked when a response message from duplex string message receiver was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.IReliableCommandsFactory">
            <summary>
            The interface declares the factory to create reliable command proxy and reliable command.
            The reliable 'command proxy' and 'command' send acknowledge messages as a confirmation that the request
            or the resposne was delivered.<br/>
            The reliable command proxy can be used only with reliable command.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandsFactory.CreateReliableCommandProxy``2">
            <summary>
            Creates the reliable command proxy.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
            <returns>reliable command proxy</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandsFactory.CreateReliableCommand``2(System.Action{Eneter.Messaging.EndPoints.Commands.IReliableCommandContext{``0,``1}},Eneter.Messaging.EndPoints.Commands.EProcessingStrategy)">
             <summary>
             Creates the reliable command.
             </summary>
             <typeparam name="_ReturnDataType">type of return data</typeparam>
             <typeparam name="_InputDataType">type of input data</typeparam>
             <returns>reliable command</returns>
             <example>
             The following example shows how to implement the method performing a command,
             so that the method processes Pause, Resume, Cancel and Failures.
             <code>
             private void CommandProcessingMethod(ICommandContext&lt;int, bool&gt; commandContext)
             {
                 try
                 {
                     // Read the input data.
                     DataFragment&lt;bool&gt; anInputDataFragment = commandContext.DequeueInputData();
                     bool anInputData = anInputDataFragment.Data;    
            
                     for (int i = 0; i &lt; 100; ++i)
                     {
                         // Simulate some work.
                         Thread.Sleep(100);
             
                         // Wait if pause is requested.
                         if (commandContext.CurrentRequest == ECommandRequest.Pause)
                         {
                             // Notify the command proxy that the command was paused.
                             commandContext.ResponsePause();
             
                             // Wait until resumed or canceled.
                             commandContext.WaitIfPause();
                         }
             
                         // If the cancel is requested then stop the command.
                         // Note: The check for the cancel is placed after the check for the pause
                         //       because when the command is paused it can be canceled.
                         if (commandContext.CurrentRequest == ECommandRequest.Cancel)
                         {
                             // Notify the command proxy that the command was canceled.
                             commandContext.ResponseCancel();
                             return;
                         }
             
                         // Notify the progress.
                         ECommandState aState = (i == 99) ? ECommandState.Completed : ECommandState.InProgress;
                         commandContext.Response(aState, i + 1);
                     }
                 }
                 catch (Exception err)
                 {
                     commandContext.ResponseFailure(err.Message);
                 }
             }
             </code>
             </example>
        </member>
        <member name="T:ReadOnlyDictionary`2">
            <summary>
            Provides the base class for a generic read-only dictionary.
            </summary>
            <typeparam name="TKey">
            The type of keys in the dictionary.
            </typeparam>
            <typeparam name="TValue">
            The type of values in the dictionary.
            </typeparam>
            <remarks>
            <para>
            An instance of the <b>ReadOnlyDictionary</b> generic class is
            always read-only. A dictionary that is read-only is simply a
            dictionary with a wrapper that prevents modifying the
            dictionary; therefore, if changes are made to the underlying
            dictionary, the read-only dictionary reflects those changes. 
            See <see cref="T:System.Collections.Generic.Dictionary`2"/> for a modifiable version of 
            this class.
            </para>
            <para>
            <b>Notes to Implementers</b> This base class is provided to 
            make it easier for implementers to create a generic read-only
            custom dictionary. Implementers are encouraged to extend this
            base class instead of creating their own. 
            </para>
            </remarks>
        </member>
        <member name="M:ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Initializes a new instance of the
            <see cref="T:ReadOnlyDictionary`2" /> class that wraps
            the supplied <paramref name="dictionaryToWrap"/>.
            </summary>
            <param name="dictionaryToWrap">The <see cref="T:IDictionary`2" />
            that will be wrapped.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the dictionary is null.
            </exception>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Add(`0,`1)">
            <summary>This method is not supported by the 
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="key">
            The object to use as the key of the element to add.</param>
            <param name="value">
            The object to use as the value of the element to add.</param>
        </member>
        <member name="M:ReadOnlyDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the <see cref="T:ReadOnlyDictionary`2" />
            contains the specified key.</summary>
            <returns>
            True if the <see cref="T:ReadOnlyDictionary`2" /> contains
            an element with the specified key; otherwise, false.
            </returns>
            <param name="key">The key to locate in the
            <see cref="T:ReadOnlyDictionary`2"></see>.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the key is null.
            </exception>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Remove(`0)">
            <summary>
            This method is not supported by the <see cref="T:ReadOnlyDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            True if the element is successfully removed; otherwise, false.
            </returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns, contains the value
            associated with the specified key, if the key is found;
            otherwise, the default value for the type of the value parameter.
            This parameter is passed uninitialized.</param>
            <returns>
            <b>true</b> if the <see cref="T:ReadOnlyDictionary`2" /> contains
            an element with the specified key; otherwise, <b>false</b>.
            </returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>This method is not supported by the
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="item">
            The object to add to the <see cref="T:ICollection`1"/>.
            </param>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Clear">
            <summary>This method is not supported by the 
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the <see cref="T:ICollection`1"/> contains a
            specific value.
            </summary>
            <param name="item">
            The object to locate in the <see cref="T:ICollection`1"/>.
            </param>
            <returns>
            <b>true</b> if item is found in the <b>ICollection</b>; 
            otherwise, <b>false</b>.
            </returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the ICollection to an Array, starting at a
            particular Array index. 
            </summary>
            <param name="array">The one-dimensional Array that is the
            destination of the elements copied from ICollection.
            The Array must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>This method is not supported by the
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="item">
            The object to remove from the ICollection.
            </param>
            <returns>Will never return a value.</returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey@TValue}}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A IEnumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An IEnumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            For a description of this member, see <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>. 
            </summary>
            <param name="array">
            The one-dimensional Array that is the destination of the elements copied from 
            ICollection. The Array must have zero-based indexing.
            </param>
            <param name="index">
            The zero-based index in Array at which copying begins.
            </param>
        </member>
        <member name="P:ReadOnlyDictionary`2.Count">
            <summary>
            Gets the number of key/value pairs contained in the
            <see cref="T:ReadOnlyDictionary`2"></see>.
            </summary>
            <value>The number of key/value pairs.</value>
            <returns>The number of key/value pairs contained in the
            <see cref="T:ReadOnlyDictionary`2"></see>.</returns>
        </member>
        <member name="P:ReadOnlyDictionary`2.Keys">
            <summary>Gets a collection containing the keys in the
            <see cref="T:ReadOnlyDictionary{TKey,TValue}"></see>.</summary>
            <value>A <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection"/> 
            containing the keys.</value>
            <returns>A
            <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection"/>
            containing the keys in the
            <see cref="T:System.Collections.Generic.Dictionary`2"></see>.
            </returns>
        </member>
        <member name="P:ReadOnlyDictionary`2.Values">
            <summary>
            Gets a collection containing the values of the
            <see cref="T:ReadOnlyDictionary`2"/>.
            </summary>
            <value>The collection of values.</value>
        </member>
        <member name="P:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#IsReadOnly">
            <summary>Gets a value indicating whether the dictionary is read-only.
            This value will always be true.</summary>
        </member>
        <member name="P:ReadOnlyDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the dictionary
            is synchronized (thread safe).
            </summary>
        </member>
        <member name="P:ReadOnlyDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to dictionary.
            </summary>
        </member>
        <member name="P:ReadOnlyDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <returns>
            The value associated with the specified key. If the specified key
            is not found, a get operation throws a 
            <see cref="T:System.Collections.Generic.KeyNotFoundException" />,
            and a set operation creates a new element with the specified key.
            </returns>
            <param name="key">The key of the value to get or set.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the key is null.
            </exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            The property is retrieved and key does not exist in the collection.
            </exception>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.DuplexRouterFactory">
            <summary>
            Implements the factory creating duplex router.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IDuplexRouterFactory">
            <summary>
            Declares the factory creating duplex router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouterFactory.CreateDuplexRouter">
            <summary>
            Creates the duplex router.
            </summary>
            <returns>duplex router</returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.DuplexRouterFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the duplex router factory.
            </summary>
            <param name="duplexOutputChannelMessaging">
            the messaging system factory used to create duplex output channels
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.DuplexRouterFactory.CreateDuplexRouter">
            <summary>
            Creates the duplex router.
            </summary>
            <returns>duplex router</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.LoadBalancer.NamespaceDoc">
            <summary>
            Functionality to distribute the workload across a farm of receivers.
            </summary>
            <remarks>
            The load balancer maintains a list of receivers processing a certain request.
            When the balancer receives the request, it chooses which receiver shall process it,
            so that all receivers are loaded optimally.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.NamespaceDoc">
            <summary>
            Functionality for the component forwarding messages to all attached receivers.
            </summary>
            <remarks>
            Receives messages and forwards them to all attached receivers.
            The message is then processed by more services in parallel.
            E.g. If a client needs to evaluate results from more different services.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDispatcher">
            <summary>
            Declares the dispatcher.
            </summary>
            <remarks>
            The dispatcher has attached more input channels and more output channels.<br/>
            When it receives some message via the input channel, it forwards the message to all output channels.<br/>
            This is the one-way dispatcher. It means it can forward messages but cannot route back response messages.<br/>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels">
            <summary>
            The interface declares methods to attach/detach multiple IInputChannel.
            </summary>
            <remarks>
            Some comunication components need to attach several channels.
            Components using multiple input channels are used in one-way communication.
            They are able to listen to messages on more input channels (addresses).
            But they are not able to send back response messages. <br/>
            E.g. <see cref="T:Eneter.Messaging.Nodes.Dispatcher.IDispatcher"/>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels.AttachInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel)">
            <summary>
            Attaches the input channel.
            It stores the reference to the input channel and starts the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels.DetachInputChannel">
            <summary>
            Detaches the input channel.
            It cleans the reference to the input channel and stops the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels.DetachInputChannel(System.String)">
            <summary>
            Detaches the input channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels.IsInputChannelAttached">
            <summary>
            Returns true if the reference to the input channel is stored. <br/>
            </summary>
            <remarks>
            Notice, unlike version 1.0, the true value does not mean the channel is listening.
            The method AttachInputChannel() starts also the listening, but if the listening stops (for whatever reason),
            the input channel stays attached. To figure out if the input channel is listening use property <see cref="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.IsListening"/>.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels.AttachedInputChannels">
            <summary>
            Returns attached input channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.Dispatcher.OnMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs)">
            <summary>
            The method is called when a message is received from an input channel.
            The message is then sent to all attached output channels.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory">
            <summary>
            Implements the messaging system delivering messages with using .Net thread pool.
            </summary>
            <remarks>
            The messages are put to the queue of .Net thread pool. The receiving input channel is then called
            in the context of the assigned thread from the pool. Therefore the input channel can process more messages at once
            and also can notify the subscriber from more different threads at the same time. <br/>
            <b>Therefore do not forget to be careful and avoid race conditioning.</b>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory representing the messaging system.
            </summary>
            <remarks>
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the factory representing the messaging system.
            </summary>
            <remarks>
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </remarks>
            <param name="protocolFormatter">formatter used to encode low-level messages between channels</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the specified input channel via the thread pool.
            </summary>
            <remarks>
            The output channel can send messages only to the input channel and not to the duplex input channel.
            </remarks>
            <param name="channelId">Identifies the receiving input channel.</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel via the thread pool.
            </summary>
            <remarks>
            The input channel can receive messages only from the output channel and not from the duplex output channel.
            </remarks>
            <param name="channelId">Identifies this input channel.</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the thread pool.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the thread pool.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using the thread pool.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">Identifies this duplex input channel.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory">
            <summary>
            Implements the messaging system delivering messages via TCP.
            </summary>
            <remarks>
            It creates the communication channels using TCP for sending and receiving messages.
            The channel id must be a valid URI address. E.g.: tcp://127.0.0.1:6080/. <br/>
            Notice, Silverlight and Windows Phone do not support TCP listeners.
            Therefore, only sending of messages (and receiving response messages) is possible on these platforms.<br/>
            More details:<br/>
            TCP in Silverlight is restricted to ports 4502 - 4532 and requires the TcpPolicyServer running on the service side.<br/>
            Windows Phone 7.0 does not suport TCP at all. The TCP is supported from Windows Phone 7.1. TCP in Windows Phone 7.1
            does not require TcpPolicyServer and is not restricted to certain ports as in Silverlight. 
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.#ctor">
            <summary>
            Constructs the TCP messaging factory.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.EConcurrencyMode)">
            <summary>
            Constructs the TCP messaging factory.
            </summary>
            <param name="concurrencyMode">
            Specifies the threading mode for receiving messages in input channel and duplex input channel.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.EConcurrencyMode,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter{System.Byte[]})">
            <summary>
            Constructs the TCP messaging factory.
            </summary>
            <param name="concurrencyMode">
            Specifies the threading mode for receiving messages in input channel and duplex input channel.</param>
            <param name="protocolFormatter">formatter used for low-level messaging between output and input channels.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the specified input channel by using TCP.
            </summary>
            <remarks>
            The output channel can send messages only to the input channel and not to the duplex input channel.
            </remarks>
            <param name="channelId">Identifies the receiving input channel. The channel id must be a valid URI address e.g. tcp://127.0.0.1:8090/ </param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from output channel by using TCP.<br/>
            The method is not supported in Silverlight and Windows Phone.
            </summary>
            <remarks>
            The input channel can receive messages only from the output channel and not from the duplex output channel.
            </remarks>
            <param name="channelId">The addres, the input channel will listen to. The channel id must be a valid URI address e.g. tcp://127.0.0.1:8090/ </param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using TCP.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid URI address e.g. tcp://127.0.0.1:8090/ </param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using TCP.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid URI address e.g. tcp://127.0.0.1:8090/ </param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using TCP.
            The method is not supported in Silverlight and Windows Phone.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">Identifies this duplex input channel. The channel id must be a valid URI address (e.g. tcp://127.0.0.1:8090/) the input channel will listen to.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.ServerSecurityStreamFactory">
            <summary>
            Sets or gets the security stream factory for the server.
            If the factory is set, then the input channel and the duplex input channel use it to establish
            the secure communication.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.ClientSecurityStreamFactory">
            <summary>
            Sets and gets the security stream factory for the client.
            If the factory is set, then the output channel and the duplex output channel use it to establish
            the secure communication.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingSystemBase">
            <summary>
            Internal interface for implementing message systems.
            Note: This is just a helper interface helping implementation of some messaging system.
                  It is not mandatory to use this interface to implement the messaging system.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingSystemBase.SendMessage(System.String,System.Object)">
            <summary>
            Sends the message.
            </summary>
            <param name="channelId">channel id receiving the message</param>
            <param name="message">message to be sent</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingSystemBase.RegisterMessageHandler(System.String,System.Action{System.Object})">
            <summary>
            Registers the listener.
            </summary>
            <param name="channelId">channel id registering for receiving messages</param>
            <param name="messageHandler">method handling the incoming message</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingSystemBase.UnregisterMessageHandler(System.String)">
            <summary>
            Unregisters the listener.
            </summary>
            <param name="channelId">channel id to be unregistered from listening</param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexInputChannel">
            <summary>
            Implements the duplex input channel based on Http.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpInputChannelBase">
            <summary>
            Base class for the http based input channel. It implements basic
            common functionality for HttpInputChannel and HttpDuplexInputChannel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpInputChannelBase.StartListening">
            <summary>
            Starts Http listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpInputChannelBase.StopListening">
            <summary>
            Stops the Http listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpInputChannelBase.HandleConnection(Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpRequestContext)">
            <summary>
            Processes the Http requests.
            It gets the message and puts it to the queue. The message is then removed from the queue by
            the working thread that notifies the subscriber.
            </summary>
            <param name="httpListenerContext"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexInputChannel.#ctor(System.String,System.Int32,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter{System.Byte[]})">
            <summary>
            Constructs the duplex input channel.
            </summary>
            <param name="channelId">Uri of the duplex input channel.</param>
            <param name="responseReceiverInactivityTimeout">maximum time the Http response receiver does not poll for response messages</param>
            <param name="protocolFormatter">formatter used to encode low-level messages between channels</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexInputChannel.SendResponseMessage(System.String,System.Object)">
            <summary>
            Sends the response message to the specified response receiver.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexInputChannel.DisconnectResponseReceiver(System.String)">
            <summary>
            Disconnects the response receiver.
            </summary>
            <param name="responseReceiverId"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexInputChannel.HandleConnection(Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpRequestContext)">
            <summary>
            Is called when the Http connection is established. It is called from DoHttpListening().
            </summary>
            <param name="httpRequestContext"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory">
            <summary>
            Extends the communication by reliable messaging and buffered messaging.
            </summary>
            <remarks>
            This is the composite messaging system that consist of:
            <ol>
            <li>Reliable Messaging  --> confirms, the sent message was delivered</li>
            <li>Buffered Messaging  --> buffering messages if disconnected (while automatically trying to reconnect)</li>
            <li>Messaging System    --> responsible for sending and receiving messages</li>
            </ol>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            The serializer for the reliable messages is set to <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The maximum time, the acknowledge message must be received is set to 11 seconds.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory with specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
            <param name="serializer">serializer used to serialize the acknowledge communication</param>
            <param name="acknowledgeTimeout">the maximum time, until the acknowledge message is expected. If the time is exceeded
            it will be notified, the message was not delivered.</param>
            <param name="maxOfflineTime">the max time, the communicating applications can be disconnected</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the input channel.
            </summary>
            <remarks>
            This output channel provides the buffered messaging. Since the the output channel does not receive messages,
            the reliable messaging is not applicable.<br/>
            If the input channel is not available, the sent messages are stored in the buffer from where they are sent again
            when the input channel is available.
            If the message is not sent from the buffer (because the input channel is not available) within the specified offline time,
            the message is removed from the buffer.
            <br/>
            Note, when the message was successfully sent, it does not mean the message was delivered. It still can be lost on the way.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel.
            </summary>
            <remarks>
            The buffering as well as reliable messages are not applicable.
            This method just uses the underlying messaging system to create the input channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the reliable duplex output channel that can send messages and receive response messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </summary>
            <remarks>
            This duplex output channel provides the reliable messaging and the buffered messaging.
            If the connection is not established, it puts sent messages to the buffer while trying to reconnect.
            If the reliable duplex input channel receives the message, it sends back the acknowledge message.
            When the reliable duplex output channel receives the acknowledge message it invokes <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageDelivered"/>.
            If the acknowledge message is not delivered until the specified time, it invokes <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageNotDelivered"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the reliable duplex output channel that can send messages and receive response messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </summary>
            <remarks>
            This duplex output channel provides the reliable messaging and the buffered messaging.
            If the connection is not established, it puts sent messages to the buffer while trying to reconnect.
            If the reliable duplex input channel receives the message, it sends back the acknowledge message.
            When the reliable duplex output channel receives the acknowledge message it invokes <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageDelivered"/>.
            If the acknowledge message is not delivered until the specified time, it invokes <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageNotDelivered"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">the response receiver id used by the duplex input channel to distinguish between
            connected duplex output channels</param>
            <returns>reliable duplex output channnel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the reliable duplex input channel that can receive messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/> and send back
            response messages.
            </summary>
            <remarks>
            This duplex output channel provides the reliable messaging and the buffered messaging.
            If the connection is not established, it puts sent response messages to the buffer.
            If the reliable duplex output channel receives the response message, it sends back the acknowledge message.
            When the reliable duplex input channel receives the acknowledge message it invokes <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.ResponseMessageDelivered"/>.
            If the acknowledge message is not delivered until the specified time, it invokes <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.ResponseMessageNotDelivered"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex input channnel</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.NamespaceDoc">
            <summary>
            Monitoring the connection between communicating applications.
            </summary>
            <remarks>
            The monitoring is realized by sending 'ping' messages and receiving 'ping' responses.
            If the sending of the 'ping' fails or the 'ping' response is not received within the specified
            time, the connection is considered to be broken.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProviderFactory">
            <summary>
            The interface declares the factory to create the connection provider. The connection provider
            helps to attach a channel to a component or to connect two components with a channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProviderFactory.CreateConnectionProvider(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the connenction provider.
            </summary>
            <param name="messagingSystem">Messaging system the connection provider will use to create channels.</param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessagesFactory">
            <summary>
            Implements the factory to create senders and receivers of sequence of typed messages.
            The senders and receivers ensure the correct order of messages in the sequence.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessagesFactory">
            <summary>
            The interface declares the factory to create senders and receivers of sequence of typed messages.
            The senders and receivers ensure the correct order of messages in the sequence.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessagesFactory.CreateTypedSequencedMessageSender``1">
            <summary>
            Creates the sender of messages of specified type.
            </summary>
            <typeparam name="_MessageDataType">The type of the message.</typeparam>
            <returns>typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessagesFactory.CreateTypedSequencedMessageReceiver``1">
            <summary>
            Creates the receiver of messages of specified type.
            </summary>
            <typeparam name="_MessageDataType">The type of the message.</typeparam>
            <returns>typed sequenced message receiver</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessagesFactory.#ctor">
            <summary>
            Constructs the sequences typed messages factory with xml string serializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the sequenced typed message factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessagesFactory.CreateTypedSequencedMessageSender``1">
            <summary>
            Creates the sender of messages of specified type.
            </summary>
            <typeparam name="_MessageDataType">The type of the message.</typeparam>
            <returns>typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessagesFactory.CreateTypedSequencedMessageReceiver``1">
            <summary>
            Creates the receiver of messages of specified type.
            </summary>
            <typeparam name="_MessageDataType">The type of the message.</typeparam>
            <returns>typed sequenced message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessageReceiver`1">
            <summary>
            The interface declares the strongly typed message receiver.
            The receiver is able to receive messages of the specified type via one-way input channel.
            </summary>
            <typeparam name="_MessageDataType">
            Type of the message.
            </typeparam>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessageReceiver`1.MessageReceived">
            <summary>
            The event is invoked when a typed message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceiver`1.MessageReceived">
            <summary>
            The event is rised when the message is received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageSender">
            <summary>
            The interface declares the reliable string message sender.
            The reliable string message sender can send string messages and receive string response messages.
            In addition it provides events notifying whether the messages were delivered.
            The reliable string message sender can be used only with the reliable string message receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageSender.SendMessage(System.String)">
            <summary>
            Sends the string message.
            </summary>
            <param name="message">text message</param>
            <returns>id of the message</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageSender.ResponseReceived">
            <summary>
            The event is invoked when a response message from the reliable string message receiver was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageSender.MessageDelivered">
            <summary>
            The event is invoked when the sent message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageSender.MessageNotDelivered">
            <summary>
            The event is invoked when the sent message was not delivered within the specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver">
            <summary>
            The interface declares the reliable string message receiver.
            The reliable string message receiver can receiver string messages and response string messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.SendResponseMessage(System.String,System.String)">
            <summary>
            Sends the response message back to the duplex string message sender.
            </summary>
            <param name="responseReceiverId">identifies the duplex string message sender that will receive the response</param>
            <param name="responseMessage">response message</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.RequestReceived">
            <summary>
            The event is invoked when the message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.ResponseReceiverConnected">
            <summary>
            The event is invoked when a duplex string message sender opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a duplex string message sender closed the connection.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.IReliableCommand`2">
            <summary>
            The interface declares the reliable command.
            The command is able to receive typed request messages and return typed response messages.
            The command can be paused, resumed or canceled.
            In additition the reliable command provides notifications whether the response messages were
            received by the reliable proxy command. <br/>
            The reliable command can be used only with reliable proxy command.
            </summary>
            <typeparam name="_ReturnDataType">Type of return data.</typeparam>
            <typeparam name="_InputDataType">Type of input data.</typeparam>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommand`2.ErrorReceived">
            <summary>
            The event is invoked when an error was detected during receiving the request. (e.g. a deserialization error)
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommand`2.CommandProxyConnected">
            <summary>
            The event is invoked when the command proxy was connected to the command.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommand`2.CommandProxyDisconnected">
            <summary>
            The event is invoked when the command proxy disconnected from the command.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommand`2.ResponseMessageDelivered">
            <summary>
            The event is invoked when the command proxy confirmed the response message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommand`2.ResponseMessageNotDelivered">
            <summary>
            The event is invoked when the command proxy does not confirm, that the response message was delivered.
            (If the message is not delivered within desired time.)
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommand`2.AttachReliableInputChannel(Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel and starts listening.
            </summary>
            <param name="duplexInputChannel"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommand`2.DetachReliableInputChannel">
            <summary>
            Detaches the duplex input channel and stops the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommand`2.OnMessageReceived(System.Object,Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs{Eneter.Messaging.EndPoints.Commands.CommandInputData{`1}})">
            <summary>
            The method is called when a request is received.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommand`2.CommandProcessingAsyncCallback(System.IAsyncResult)">
            <summary>
            The method is called when the asynchronous call to process the command is finished.
            (in case of parallel processing mode)
            </summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommand`2.WorkingThreadHandler(Eneter.Messaging.EndPoints.Commands.ReliableCommandItem{`0,`1})">
            <summary>
            Removes the 'execute command' requests from the queue and execute them.
            The method is used in case of single thread mode.
            </summary>
            <param name="commandContext"></param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandsFactory">
            <summary>
            Implements the factory to create command proxy and command.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ICommandsFactory">
            <summary>
            The interface declares the factory to create command proxy and command.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandsFactory.CreateCommandProxy``2">
            <summary>
            Creates the command proxy.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
            <returns>command proxy</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandsFactory.CreateCommand``2(System.Action{Eneter.Messaging.EndPoints.Commands.ICommandContext{``0,``1}},Eneter.Messaging.EndPoints.Commands.EProcessingStrategy)">
             <summary>
             Creates the command.
             </summary>
             <typeparam name="_ReturnDataType">type of return data</typeparam>
             <typeparam name="_InputDataType">type of input data</typeparam>
             <returns>command</returns>
             <example>
             The following example shows how to implement the method performing a command,
             so that the method processes Pause, Resume, Cancel and Failures.
             <code>
             private void CommandProcessingMethod(ICommandContext&lt;int, bool&gt; commandContext)
             {
                 try
                 {
                     // Read the input data.
                     DataFragment&lt;bool&gt; anInputDataFragment = commandContext.DequeueInputData();
                     bool anInputData = anInputDataFragment.Data;    
            
                     for (int i = 0; i &lt; 100; ++i)
                     {
                         // Simulate some work.
                         Thread.Sleep(100);
             
                         // Wait if pause is requested.
                         if (commandContext.CurrentRequest == ECommandRequest.Pause)
                         {
                             // Notify the command proxy that the command was paused.
                             commandContext.ResponsePause();
             
                             // Wait until resumed or canceled.
                             commandContext.WaitIfPause();
                         }
             
                         // If the cancel is requested then stop the command.
                         // Note: The check for the cancel is placed after the check for the pause
                         //       because when the command is paused it can be canceled.
                         if (commandContext.CurrentRequest == ECommandRequest.Cancel)
                         {
                             // Notify the command proxy that the command was canceled.
                             commandContext.ResponseCancel();
                             return;
                         }
             
                         // Notify the progress.
                         ECommandState aState = (i == 99) ? ECommandState.Completed : ECommandState.InProgress;
                         commandContext.Response(aState, i + 1);
                     }
                 }
                 catch (Exception err)
                 {
                     commandContext.ResponseFailure(err.Message);
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandsFactory.#ctor">
            <summary>
            Constructs the factory with binary serializer.
            <b>Note: The serializer is XmlStringSerializer in case of Silverlight.</b>
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandsFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandsFactory.#ctor(Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessagesFactory)">
            <summary>
            Constructs the factory with the specified duplex typed sequenced messages factory.
            The duplex typed sequenced messages are used internally by the command (and command proxy) so
            you can provide your own implementation if needed.
            </summary>
            <param name="duplexTypedSequencedMessagesFactory">duplex typed sequenced messages factory</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandsFactory.CreateCommandProxy``2">
            <summary>
            Creates the command proxy.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
            <returns>command proxy</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandsFactory.CreateCommand``2(System.Action{Eneter.Messaging.EndPoints.Commands.ICommandContext{``0,``1}},Eneter.Messaging.EndPoints.Commands.EProcessingStrategy)">
            <summary>
            Creates the command.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
            <returns>command</returns>
            <example>
            The following example shows how to implement the method performing a command,
            so that the method processes Pause, Resume, Cancel and Failures.
            <code>
            private void CommandProcessingMethod(ICommandContext&lt;int, bool&gt; commandContext)
            {
                try
                {
                    // Read the input data.
                    DataFragment&lt;bool&gt; anInputDataFragment = commandContext.DequeueInputData();
                    bool anInputData = anInputDataFragment.Data;    
            
                    for (int i = 0; i &lt; 100; ++i)
                    {
                        // Simulate some work.
                        Thread.Sleep(100);
            
                        // Wait if pause is requested.
                        if (commandContext.CurrentRequest == ECommandRequest.Pause)
                        {
                            // Notify the command proxy that the command was paused.
                            commandContext.ResponsePause();
            
                            // Wait until resumed or canceled.
                            commandContext.WaitIfPause();
                        }
            
                        // If the cancel is requested then stop the command.
                        // Note: The check for the cancel is placed after the check for the pause
                        //       because when the command is paused it can be canceled.
                        if (commandContext.CurrentRequest == ECommandRequest.Cancel)
                        {
                            // Notify the command proxy that the command was canceled.
                            commandContext.ResponseCancel();
                            return;
                        }
            
                        // Notify the progress.
                        ECommandState aState = (i == 99) ? ECommandState.Completed : ECommandState.InProgress;
                        commandContext.Response(aState, i + 1);
                    }
                }
                catch (Exception err)
                {
                    commandContext.ResponseFailure(err.Message);
                }
            }
            </code>
            </example>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.NamespaceDoc">
            <summary>
            The namespace contains the supporting functionality for serialization and deserialiazation of data.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.DataFragment`1">
            <summary>
            Implements the data fragment for specified data type.
            </summary>
            <typeparam name="_DataType">data type contained in the fragment</typeparam>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.DataFragment`1.#ctor">
            <summary>
            Default constructor used for deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.DataFragment`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>
            Constructs the fragment from parameters.
            </summary>
            <param name="data">Data contained in the fragment.</param>
            <param name="sequenceId">Identifies the sequence where the fragment belongs.</param>
            <param name="index">Number of the fragment.</param>
            <param name="isFinal">Indicates whether the fragmant is the last one.</param>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.DataFragment`1.Data">
            <summary>
            Data contained in the fragment.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue">
            <summary>
            Implements the queue for messages of type object.
            One or more threads can put messages into the queue and other threads
            can remove them.
            If the queue is empty, then the thread reading messages is blocked until the message
            is put to the queue or the thread is unblocked.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1">
            <summary>
            Implements the message queue.
            One or more threads can put messages into the queue and other threads
            can remove them.
            If the queue is empty, then the thread reading the messages is blocked until the message
            is put to the queue or the thread is unblocked.
            </summary>
            <typeparam name="_MessageType">Type of the message.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.EnqueueMessage(`0)">
            <summary>
            Puts message to the queue.
            </summary>
            <param name="message">message that shall be enqueued</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.DequeueMessage">
            <summary>
            Removes the first message from the queue. If the queue is empty the thread is blocked until a message is put to the queue.
            To unblock waiting threads, use UnblockProcesseingThreads().
            </summary>
            <returns>message, it returns null if the waiting thread was unblocked but there is no message in the queue.</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.PeekMessage">
            <summary>
            Reads the first message from the queue. If the queue is empty the thread is blocked until a message is put to the queue.
            To unblock waiting threads, use UnblockProcesseingThreads().
            </summary>
            <returns>
            message, it returns null if the waiting thread was unblocked but there is no message in the queue.
            </returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.DequeueMessage(System.Int32)">
            <summary>
            Removes the first message from the queue. If the queue is empty the thread is blocked until the specified timeout.
            The method UnblockProcesseingThreads() unblocks threads waiting in this method.
            </summary>
            <param name="millisecondsTimeout">Maximum waiting time for the message. If the time is exceeded the TimeoutException is thrown.</param>
            <returns>message</returns>
            <exception cref="T:System.TimeoutException">when the specified timeout is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.PeekMessage(System.Int32)">
            <summary>
            Reads the first message from the queue. If the queue is empty the thread is blocked until a message is put to the queue.
            To unblock waiting threads, use UnblockProcesseingThreads().
            </summary>
            <param name="millisecondsTimeout">
            Maximum waiting time for the message. If the time is exceeded the TimeoutException is thrown.
            </param>
            <returns>message</returns>
            <exception cref="T:System.TimeoutException">when the specified timeout is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.Clear">
            <summary>
            Deletes all items from the message queue.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.UnblockProcessingThreads">
            <summary>
            Releases all threads waiting for messages in DequeueMessage() and sets the queue to the unblocking mode.
            </summary>
            <remarks>
            When the queue is in unblocking mode, the dequeue or peek will not block if data is not available but
            it will return null or default values.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.BlockProcessingThreads">
            <summary>
            Sets the queue to the blocking mode.
            </summary>
            <remarks>
            When the queue is in blocking mode, the dequeue and peek will block until data is available.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.WaitForQueueCall(System.Func{`0})">
            <summary>
            Waits until something is in the queue and then calls the specified delegate.
            If the waiting thread is released (by UnblockProcessingThreads) but the queue is still empty, it returns the default
            value of the specified template type.
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.myMessageQueue">
            <summary>
            Queue for messages.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.myIsBlockingMode">
            <summary>
            Indicates weather the reading from the queue blocks until data is available.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.IsBlockingMode">
            <summary>
            Returns true if the queue blocks threads during dequeue and peek.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.Count">
            <summary>
            Returns number of messages in the queue.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.NamespaceDoc">
            <summary>
            Functionality for routing messages to a different address.
            </summary>
            <remarks>
            Router receives messages and routes them to a different preconfigured address.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IRouter">
            <summary>
            Declares the one-way router.
            </summary>
            <remarks>
            The router has attached more input channels and more output channels.<br/>
            When it receives some message via the input channel, it forwards the message to all configured output channels.<br/>
            This the one-way router. Therefore, it can forward messages, but cannot route back response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IRouter.AddConnection(System.String,System.String)">
            <summary>
            Configures connection between the input channel and the output channel.
            When the connection is established then all messages comming via this input channel will be forwarded
            to all output channels configured for that output channel.
            </summary>
            <param name="inputChannelId">input channel identifier</param>
            <param name="outputChannelId">output channel identifier</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IRouter.RemoveConnection(System.String,System.String)">
            <summary>
            Removes configured connection between the input channel and the output channel.
            </summary>
            <param name="inputChannelId">input channel identifier</param>
            <param name="outputChannelId">output channel identifier</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IRouter.RemoveInputChannelConnections(System.String)">
            <summary>
            Removes all configured connctions for the given input channel.
            </summary>
            <param name="inputChannelId">input channel identifier</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IRouter.RemoveOutputChannelConnections(System.String)">
            <summary>
            Removes all configured connections for the given output channel.
            </summary>
            <param name="outputChannelId">output channel identifier</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.Router.AddConnection(System.String,System.String)">
            <summary>
            Creates the connection between the input channel and the output channel.
            One input channel can have configured connection with more output channels.
            When a message is received from the input channel the message is then forwarded to all
            output channels that are connected with the input channel.
            </summary>
            <param name="inputChannelId"></param>
            <param name="outputChannelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.Router.OnChannelMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs)">
            <summary>
            The method is called wehen the message is received.
            The message is then forwarded to all created connections.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage">
            <summary>
            Represents a data message received via websocket communication.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage.#ctor(System.Boolean,System.IO.Stream)">
            <summary>
            Constructs the message - only eneter framework can construct it.
            </summary>
            <param name="isText">true if it is a text message.</param>
            <param name="inputStream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage.GetWholeMessage">
            <summary>
            Returns the whole incoming message.
            </summary>
            <remarks>
            In case the message was sent via multiple frames it waits until all frames are
            collected and then returns the result message.
            </remarks>
            <returns>received message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage.GetWholeTextMessage">
            <summary>
            Returns the whole incoming text message.
            </summary>
            <remarks>
            In case the message was sent via multiple frames it waits until all frames are
            collected and then returns the result message.<br/>
            To receive message as a text message, according to websocket protocol the message
            must be sent via the text frame.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            The message wsa not sent/received as the text message.
            I.e. the message was not sent via the text frame.
            </exception>
            <returns>received text message</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage.IsText">
            <summary>
            Returns true if the message is text. The message is text when sent via text frame.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage.InputStream">
            <summary>
            Returns the input stream user can use to read the message from.
            </summary>
            <remarks>
            The reading of the stream blocks if desired amount of data is not available and
            not all message frames were received.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transferring messages between threads by using the working
            thread processing messages from the queue.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.NamespaceDoc">
            <summary>
            SSL and Negotiate security protocol for the TCP communication.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.SimpleInputChannel">
            <summary>
            Internal basic implementation of the input channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.SimpleInputChannel.StartListening">
            <summary>
            Registers the delegate in the messaging system to receive messages from a desired channel id and starts the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.SimpleInputChannel.StopListening">
            <summary>
            Unregisters the channel id from the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.SimpleInputChannel.HandleMessage(System.Object)">
            <summary>
            Handles the message coming from the messaging system.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType">
            <summary>
            Indicates the type of the low-level protocol message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.Unknown">
            <summary>
            Unknown message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.OpenConnectionRequest">
            <summary>
            Open connection request message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.CloseConnectionRequest">
            <summary>
            Close connection request message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.PollRequest">
            <summary>
            Poll request message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.MessageReceived">
            <summary>
            Message or reaponse message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage">
            <summary>
            Represents decoded low-level protocol message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType,System.String,System.Object)">
            <summary>
            Constructs the protocol message from the given parameters.
            </summary>
            <param name="messageType">type of the message</param>
            <param name="responseReceiverId">client id</param>
            <param name="message">message content</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.MessageType">
            <summary>
            Type of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.ResponseReceiverId">
            <summary>
            Client id.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.Message">
            <summary>
            The content of the message or response message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory">
            <summary>
            Extends the communication by reliable messaging, buffered messaging and monitored network connection.
            </summary>
            <remarks>
            This is the composite messaging system that consist of:
            <ol>
            <li>Reliable Messaging  --> confirmation, whether the sent messages were delivered.</li>
            <li>Buffered Messaging  --> stores sent messages to the buffer if disconnected</li>
            <li>Monitored Messaging --> constantly monitores the connection</li>
            <li>Messaging System    --> responsible for sending and receiving messages</li>
            </ol>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default parameters.
            </summary>
            <remarks>
            The serializer for reliable messages and for 'ping' messages is set to <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The maximum time, the acknowledge message must be received is set to 11 seconds.
            The maximum offline time is set to 10 seconds.
            The duplex output channel will check the connection with the 'ping' once per second and the response must be received within 2 seconds.
            Otherwise the connection is closed.<br/>
            The duplex input channel expects the 'ping' request at least once per 2s. Otherwise the duplex output
            channel is disconnected.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory with specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
            <param name="serializer">serializer used to serialize acknowledge messages and 'ping' messages</param>
            <param name="acknowledgeTimeout">the maximum time until the delivery of the message must be acknowledged</param>
            <param name="maxOfflineTime">the max time, the communicating applications can be disconnected</param>
            <param name="pingFrequency">how often the duplex output channel pings the connection</param>
            <param name="pingResponseTimeout">
            For the duplex output channel: the maximum time, the response for the ping must be received
            <br/>
            For the duplex input channel: the maximum time within the ping for the connected duplex output channel
            must be received.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the input channel.
            </summary>
            <remarks>
            This output channel provides the buffered messaging. Since the the output channel does not receive messages,
            and also does not maintain the open connection, the reliable messaging and also the connection monitoring are not applicable.<br/>
            If the input channel is not available, the sent messages are stored in the buffer from where they are sent again
            when the input channel is available.
            If the message is not sent from the buffer (because the input channel is not available) within the specified offline time,
            the message is removed from the buffer.
            <br/>
            Note, when the message was successfully sent, it does not mean the message was delivered. It still can be lost on the way.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel.
            </summary>
            <remarks>
            Since the input channel does not maintain the open connection and also does not send messages,
            the reliable messaging, the buffered messaging and the connection monitoring are not applicable.
            Therefore, the implementation of the method just uses the underlying messaging to create the input channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the reliable messaging, the buffered messaging and the connection monitoring.
            The connection monitoring constantly checks, if the connection is established. If the connection is broken,
            it notifies the buffered messaging layer. The buffered messaging layer then stores sent messages in the buffer
            and tries to reconnect. If the connection is reopen, the messages from the buffer are sent. If not, it notifies,
            the connection was closed and messages are deleted from the buffer.<br/>
            The reliable messaging notifies whether the sent messages were delivered. See also <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the reliable messaging, the buffered messaging and the connection monitoring.
            The connection monitoring constantly checks, if the connection is established. If the connection is broken,
            it notifies the buffered messaging layer. The buffered messaging layer then stores sent messages in the buffer
            and tries to reconnect. If the connection is reopen, the messages from the buffer are sent. If not, it notifies,
            the connection was closed and messages are deleted from the buffer.<br/>
            The reliable messaging notifies whether the sent messages were delivered. See also <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">
            the response receiver id used by the duplex input channel to distinguish between
            connected duplex output channels
            </param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            This duplex input channel provides the reliable messaging, the buffered messaging and the connection monitoring.
            The connection monitoring constantly checks, if the duplex output channel is still connected. If the
            duplex output channel does not 'ping' anymore, the duplex output channel is disconnected and 
            it the buffered messaging layer is notified about the disconnection.
            The buffered messaging layer then stores sent response messages to the buffer and waits if the connection
            with the duplex output channel is established again.
            If the connection is reopen, the messages from the buffer are sent.
            If not, it notifies, the duplex output channel is disconnected and messages are deleted from the buffer.<br/>
            The reliable messaging notifies whether the sent response messages were delivered. See also <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.NamespaceDoc">
            <summary>
            Helper functionality to create and attach channels to components.
            </summary>
            <remarks>
            This connecting functionality helps to reduce the amount of coding. It connects communicating components with channels.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceivedEventArgs`1">
            <summary>
            The typed message received event.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceivedEventArgs`1.#ctor(`0)">
            <summary>
            Constructs the event.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event from the given error message.
            </summary>
            <param name="error"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceivedEventArgs`1.MessageData">
            <summary>
            Returns the received message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            E.g. during the deserialization of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2">
            <summary>
            The interface declares the strongly typed reliable message sender.
            The reliable sender can send typed messages and receive typed response messages.
            In addition it provides events notifying whether the message was delivered.
            The reliable typed message sender can be used only with the reliable typed message receiver.
            </summary>
            <typeparam name="_ResponseType">type of the response message</typeparam>
            <typeparam name="_RequestType">type of the message</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.SendRequestMessage(`1)">
            <summary>
            Sends the message to the reliable typed message receiver.
            </summary>
            <param name="message">message of desired type</param>
            <returns>id of the message</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.ResponseReceived">
            <summary>
            The event is invoked when the response message is received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.MessageDelivered">
            <summary>
            The event is invoked when the message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.MessageNotDelivered">
            <summary>
            The event is invoked if the event is not delivered within a specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2">
            <summary>
            The interface declares the strongly typed duplex message receiver.
            The receiver is able to receive messages of the specified type and send back response messages of specified type.
            </summary>
            <typeparam name="_ResponseType">The type of sending response messages.</typeparam>
            <typeparam name="_RequestType">The type of receiving messages.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.SendResponseMessage(System.String,`0)">
            <summary>
            Sends the response message back to the duplex typed message sender via the attached duplex input channel.
            </summary>
            <param name="responseReceiverId">identifies the duplex typed message sender that will receive the response</param>
            <param name="responseMessage">response message</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.MessageReceived">
            <summary>
            The event is invoked when the message from a duplex typed message sender was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.ResponseReceiverConnected">
            <summary>
            The event is invoked when a duplex typed message sender opened the connection via its duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a duplex typed message sender closed the connection via its duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs">
            <summary>
            The event is invoked when a string response message is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseMessage">message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs.ResponseMessage">
            <summary>
            Returns the response message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringMessagesFactory">
            <summary>
            The interface declares the factory to create string message senders and receivers.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IStringMessagesFactory">
            <summary>
            The interface declares the factory to create string message senders and receivers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IStringMessagesFactory.CreateStringMessageSender">
            <summary>
            Creates the string message sender.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IStringMessagesFactory.CreateStringMessageReceiver">
            <summary>
            Creates the string message receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringMessagesFactory.CreateStringMessageSender">
            <summary>
            Creates the string message sender.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringMessagesFactory.CreateStringMessageReceiver">
            <summary>
            Creates the string message receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.ReliableStringMessagesFactory">
            <summary>
            Implements the factory to create reliable string message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.ReliableStringMessagesFactory.CreateReliableDuplexStringMessageSender">
            <summary>
            Creates the reliable string message sender.
            </summary>
            <returns>reliable string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.ReliableStringMessagesFactory.CreateReliableDuplexStringMessageReceiver">
            <summary>
            Creates the reliable string message receiver.
            </summary>
            <returns>reliable string message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ReliableCommandsFactory">
            <summary>
            Implements the factory to create reliable command proxy and reliable command.
            The reliable 'command proxy' and 'command' send acknowledge messages as a confirmation that the request
            or the resposne was delivered.<br/>
            The reliable command proxy can be used only with reliable command.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommandsFactory.#ctor">
            <summary>
            Constructs the factory with binary serializer.<br/>
            <b>Note: The serializer is XmlStringSerializer in case of Silverlight.</b>
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommandsFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommandsFactory.#ctor(Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessagesFactory)">
            <summary>
            Constructs the factory with the specified duplex typed sequenced messages factory.
            The duplex typed sequenced messages are used internally by the command (and command proxy) so
            you can provide your own implementation if needed.
            </summary>
            <param name="reliableTypedSequencedMessagesFactory">duplex typed sequenced messages factory</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommandsFactory.CreateReliableCommandProxy``2">
            <summary>
            Creates the reliable command proxy.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
            <returns>reliable command proxy</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommandsFactory.CreateReliableCommand``2(System.Action{Eneter.Messaging.EndPoints.Commands.IReliableCommandContext{``0,``1}},Eneter.Messaging.EndPoints.Commands.EProcessingStrategy)">
             <summary>
             Creates the reliable command.
             </summary>
             <typeparam name="_ReturnDataType">type of return data</typeparam>
             <typeparam name="_InputDataType">type of input data</typeparam>
             <returns>reliable command</returns>
             <example>
             The following example shows how to implement the method performing a command,
             so that the method processes Pause, Resume, Cancel and Failures.
             <code>
             private void CommandProcessingMethod(ICommandContext&lt;int, bool&gt; commandContext)
             {
                 try
                 {
                     // Read the input data.
                     DataFragment&lt;bool&gt; anInputDataFragment = commandContext.DequeueInputData();
                     bool anInputData = anInputDataFragment.Data;    
            
                     for (int i = 0; i &lt; 100; ++i)
                     {
                         // Simulate some work.
                         Thread.Sleep(100);
             
                         // Wait if pause is requested.
                         if (commandContext.CurrentRequest == ECommandRequest.Pause)
                         {
                             // Notify the command proxy that the command was paused.
                             commandContext.ResponsePause();
             
                             // Wait until resumed or canceled.
                             commandContext.WaitIfPause();
                         }
             
                         // If the cancel is requested then stop the command.
                         // Note: The check for the cancel is placed after the check for the pause
                         //       because when the command is paused it can be canceled.
                         if (commandContext.CurrentRequest == ECommandRequest.Cancel)
                         {
                             // Notify the command proxy that the command was canceled.
                             commandContext.ResponseCancel();
                             return;
                         }
             
                         // Notify the progress.
                         ECommandState aState = (i == 99) ? ECommandState.Completed : ECommandState.InProgress;
                         commandContext.Response(aState, i + 1);
                     }
                 }
                 catch (Exception err)
                 {
                     commandContext.ResponseFailure(err.Message);
                 }
             }
             </code>
             </example>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Wrapping.WrappedData">
            <summary>
            The data structure representing the wrapped data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Wrapping.WrappedData.#ctor">
            <summary>
            Default constructor used for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Wrapping.WrappedData.#ctor(System.Object,System.Object)">
            <summary>
            Constructs wrapped data from input parameters.
            </summary>
            <param name="addedData">new data added to the original data</param>
            <param name="originalData">original data</param>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Wrapping.WrappedData.AddedData">
            <summary>
            Newly added data.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Wrapping.WrappedData.OriginalData">
            <summary>
            Original (wrapped) data.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapper">
            <summary>
            Declares the channel wrapper.
            </summary>
            <remarks>
            The channel wrapper is listening to more input channels. When it receives some message,
            it wraps the message and sends it via the only output channel.
            On the other side the message is received by channel unwrapper. The unwrapper unwraps the message
            and uses the output channel to forward the message to the correct receiver.<br/>
            The message can be sent only one-way. For the bidirectional communication see <see cref="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelWrapper"/> and
            <see cref="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper"/>.<br/>
            Notice, the 'channel wrapper' can communication only with 'channel unwrapper'. It cannot communicate with 'duplex channel unwrapper'.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapper.OnMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs)">
            <summary>
            The method is called when the channel wrapper receives a message from one of input channels.
            It wrapps the message and sends it to the output channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.HostListenerBase">
            <summary>
            Base class representing listeners listening to the particular IP address and port and
            forwarding the processing according to path to the correct handler.
            E.g. http://127.0.0.1:9055/aaa/bbb/.
            The Host listener is listening to 127.0.0.1:9055. Then it parse out the path /aaa/bbb/ and
            forwards the request to the handler responsible for this path.
            </summary>
            <remarks>
            This is used for the implementation of http and websocket listeners.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transfering messages between threads by using the thread pool.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpRequestInvoker">
            <summary>
            Invokes the HTTP request.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter">
            <summary>
            The helper allowing to observe the particular duplex output channel.
            If the channel is disconnected, it tries to reopen the connection.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel)">
            <summary>
            Constructs the reconnecter that tries to reconnect infinitely every second.
            </summary>
            <param name="duplexOutputChannel">observed duplex output channel</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel,System.TimeSpan,System.Int32)">
            <summary>
            Constructs the reconnecter from specified parameters.
            </summary>
            <param name="duplexOutputChannel">observed duplex output channel</param>
            <param name="reconnectFrequency">how often the reconnect attempt shall be performed (in case of the disconnection)</param>
            <param name="maxReconnectAttempts">max amounts of reconnect attempts. If exceeded, the ReconnectingFailed is invoked.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.EnableReconnecting">
            <summary>
            Enables the automatic reconnecting in case the disconnect is notified.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.DisableReconnecting">
            <summary>
            Disables the automatic reconnecting.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.ConnectionClosed">
            <summary>
            The event is invoked when the observed duplex output channel notified, that the connection was closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.ConnectionOpened">
            <summary>
            The event is invoked when the duplex output channel was reconnected.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.ReconnectingFailed">
            <summary>
            The event is invoked when the reopenning of the duplex output channel failed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.IsReconnectingEnabled">
            <summary>
            Returns true if the reconnecting is enabled.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1">
            <summary>
            Event when the typed sequenced response message is received.
            </summary>
            <typeparam name="_ResponseType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.#ctor(Eneter.Messaging.EndPoints.TypedSequencedMessages.ResponseMessageFragment{`0})">
            <summary>
            Constructs the event.
            </summary>
            <param name="dataFragment">message fragment</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event from the exception.
            </summary>
            <param name="receivingError">error detected during receiving of the response message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.SequenceId">
            <summary>
            Returns the sequence identifier.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.IsSequenceCompleted">
            <summary>
            Returns true if the sequence is completed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.ResponseMessage">
            <summary>
            Returns message inputData of the specified type.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            E.g. during the deserialization of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessageReceiver`1">
            <summary>
            The interface declares the typed message receiver that receives the sequence of messages.
            It is guaranteed the received sequence has the same order as was sent.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessageReceiver`1.MessageReceived">
            <summary>
            The event is invoked when the typed message (as a fragment of the sequence) is received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceiver`1.MessageReceived">
            <summary>
            The event is invoked when the typed message has received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.NamespaceDoc">
            <summary>
            The namespace contains functionality to send commands and receive responses.
            The command allows to execute, pause, resume or cancel some activity on the receiver side.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1">
            <summary>
            Event data when the response from the command was received.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.#ctor(System.String,Eneter.Messaging.EndPoints.Commands.ECommandState,`0,System.String,System.Boolean,System.String)">
            <summary>
            Constructs the event data.
            </summary>
            <param name="commandId">command identifier</param>
            <param name="commandState">state of the command</param>
            <param name="returnData">return data coming from the command</param>
            <param name="sequenceId">return data sequence id</param>
            <param name="isSequenceCompleted">tru - if the sequence of return data is completed</param>
            <param name="commandError">error message coming from the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event data when an error was detected during receiving the response.
            (e.g. a deserialization error)
            </summary>
            <param name="receivingError"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.CommandState">
            <summary>
            Gets command state.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.ReturnData">
            <summary>
            Gets return data from the command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.SequenceId">
            <summary>
            Gets the sequence is of return data from the command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.IsSequenceCompleted">
            <summary>
            Returns true - if the sequence of return data is completed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns an error detected during receiving the response. (e.g. deserialization error)
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.CommandError">
            <summary>
            Returns an error message coming from the command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.CommandId">
            <summary>
            Returns command identifier.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.GZipSerializer">
            <summary>
            Serializer compressing and decompressing data.
            </summary>
            <remarks>
            The serializer internally uses GZipStream to compress and decompress data.
            <example>
            Example shows how to serialize data.
            <code>
            // Creat the serializer.
            GZipSerializer aSerializer = new GZipSerializer();
            
            // Create some data to be serialized.
            MyData aData = new MyData();
            ...
            
            // Serialize data. Serialized data will be compressed.
            object aSerializedData = aSerializer.Serialize&lt;MyData&gt;(aData);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.GZipSerializer.#ctor">
            <summary>
            Constructs the serializer with XmlStringSerializer as the underlying serializer.
            </summary>
            <remarks>
            The serializer uses the underlying serializer to serialize data before the compression.
            It also uses the underlying serializer to deserialize decompressed data.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.GZipSerializer.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer with the given underlying serializer.
            </summary>
            <remarks>
            The serializer uses the underlying serializer to serialize data before the compression.
            It also uses the underlying serializer to deserialize decompressed data.
            </remarks>
            <param name="underlyingSerializer">underlying serializer</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.GZipSerializer.Serialize``1(``0)">
            <summary>
            Serializes the given data with using the compression.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.GZipSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes compressed data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Compressed data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper">
            <summary>
            Declares the duplex channel unwrapper.
            </summary>
            <remarks>
            The duplex channel wrapper is listening to more duplex input channels. When it receives some message,
            it wraps the message and sends it via the only duplex output channel.
            On the other side the message is received by duplex channel unwrapper. The unwrapper unwraps the message
            and uses the duplex output channel to forward the message to the correct receiver.<br/>
            The receiver can also send the response message. Then it goes the same way back.<br/>
            Notice, the 'duplex channel unwrapper' can communication only with 'duplex channel wrapper'.
            It cannot communicate with one-way 'channel wrapper'.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper.ResponseReceiverConnected">
            <summary>
            The event is invoked when the duplex channel wrapper opened the connection with this
            unwrapper via its duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the duplex channel wrapper closed the connection with this
            unwrapper via its duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType">
            <summary>
            Defines data frames as specified by the websocket protocol.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Continuation">
            <summary>
            Frame contains message data that was not sent in one 'Text' or 'Binary'.
            Message that is split into multiple frames.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Text">
            <summary>
            Frame contains UTF8 text message data.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Binary">
            <summary>
            Frame contains binary data.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Close">
            <summary>
            Control frame indicating the connection goes down.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Ping">
            <summary>
            Control frame pinging the end-point (client or server). The pong response is expected.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Pong">
            <summary>
            Control frame as a response for the ping.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.HostListenerController">
            <summary>
            Single static class ensuring it is possible to register more listeners using same IP address and port
            but different paths.
            </summary>
            <remarks>
            E.g.: The user code wants to listen to these 3 addresses:
            http://127.0.0.1:9055/aaa/bbb/
            http://127.0.0.1:9055/aaa/ccc/
            http://127.0.0.1:9055/aaa/ddd/
            
            All addresses share the same IP address and port. They are different only in paths.
            This class is responsible for maintaining listeners to IP address and port.
            So that if the user code wants to register next listener it checks if there is a listener to IP address and port.
            If yes, then it registers just the new path.
            If not, then it creates the listener to the IP address and port and register there the path.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.HostListenerController.IsListening(System.Uri)">
            <summary>
            Returns true if somebody is listening to the given uri.
            </summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs">
            <summary>
            Event argument used to notify that duplex input channel received a message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs.#ctor(System.String,System.Object,System.String,System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="channelId">Identifies the receiver of request messages. (e.g. tcp://127.0.0.1:8090/)</param>
            <param name="message">message</param>
            <param name="responseReceiverId">Unique logical id identifying the receiver of response messages.</param>
            <param name="senderAddress">Address where the sender of the request message is located. (e.g. IP address of the client)<br/>
            Can be empty string if not applicable in used messaging.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs.Message">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory">
            <summary>
            Implements the factory creating channels for the reliable communication.
            </summary>
            <remarks>
            For more details about the reliable communication, refer to <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableMessagingFactory"/>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            For the serialization of reliable messages is used <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The maximum time, the acknowledge message must be received is set to 12 seconds.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan)">
            <summary>
            Constructs the factory with specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
            <param name="serializer">serializer used to serialize the acknowledge messages</param>
            <param name="acknowledgeTimeout">the maximum time until the delivery of the message must be acknowledged</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel by using the underlying messaging system.
            </summary>
            <remarks>
            Since the output channel communicates oneway, the acknowledge messaging is not applicable.
            Therefore, the implementation of the method just uses the underlying messaging to create the output channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel by using the underlying messaging system.
            </summary>
            <remarks>
            Since the input channel communicates oneway, the acknowledge messaging is not applicable.
            Therefore, the implementation of the method just uses the underlying messaging to create the input channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the reliable duplex output channel that can send messages and receive response messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </summary>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the reliable duplex output channel that can send messages and receive response messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </summary>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">id of the response receiver</param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the reliable duplex input channel that can receive messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/> and send back
            response messages.
            </summary>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliableduplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.NamespaceDoc">
            <summary>
            Interfaces used by components to be able to attach channels.
            </summary>
            <remarks>
            In order to be able to send messages, all communication components must be able to attach channels.
            E.g. if a component needs to send messages and receive responses then it must implement
            <see cref="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel"/> to be able to attach <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel"/>.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.ReliableTypedSequencedMessagesFactory">
            <summary>
            Implements the factory to create reliable typed sequenced message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ReliableTypedSequencedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with the xml string serializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ReliableTypedSequencedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with the specified serializer.
            </summary>
            <param name="serializer"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ReliableTypedSequencedMessagesFactory.CreateReliableTypedSequencedMessageSender``2">
            <summary>
            Creates the duplex typed sequenced message sender.
            </summary>
            <typeparam name="_ResponseType">The type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">The type of sending messages.</typeparam>
            <returns>duplex typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ReliableTypedSequencedMessagesFactory.CreateReliableTypedSequencedMessageReceiver``2">
            <summary>
            Creates the duplex typed sequences message receiver.
            </summary>
            <typeparam name="_ResponseType">The type of sending response messages.</typeparam>
            <typeparam name="_RequestType">The type of receiving messages.</typeparam>
            <returns>duplex typed sequenced message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory">
            <summary>
            Implements the factory to create reliable typed message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with xml string serializer. <br/>
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageSender``2">
            <summary>
            Creates the reliable message sender.
            </summary>
            <typeparam name="_ResponseType">type of response message</typeparam>
            <typeparam name="_RequestType">type of request message</typeparam>
            <returns>reliable typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageReceiver``2">
            <summary>
            Creates the reliable message receiver.
            </summary>
            <typeparam name="_ResponseType">type of response message</typeparam>
            <typeparam name="_RequestType">type of request message</typeparam>
            <returns>reliable typed message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IStringMessageReceiver">
            <summary>
            The interface declares the string message receiver.
            The receiver is able to receive text messages via one-way input channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IStringMessageReceiver.MessageReceived">
            <summary>
            The event is invoked when a string message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IStringMessageSender">
            <summary>
            The interface declares the string message sender.
            The sender is able to send text messages via one-way output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IStringMessageSender.SendMessage(System.String)">
            <summary>
            Sends the string message via the attached output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelWrapper.OnMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            The method is called when a message from the attached duplex input channel is received.
            The received message is wrapped and sent to the duplex output channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelWrapper.OnResponseMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            The method is called when a reponse message is received from the duplex output channel.
            The received response is unwrapped and sent as a response to the matching duplex input channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Bridge.NamespaceDoc">
            <summary>
            Connects applications using a different mechanism to receive messages.
            E.g. A message received from the Silverlight via generic handler (*.ashx file).
            </summary>
            <remarks>
            The bridge allows to connect applications in case the receiving application uses some different
            mechanism for receiving messages.<br/>
            E.g. The ASP server uses message handlers (*.ashx files). Therefore, if the ASP server wants to receive
            messages from the Silverlight application, then the ASP.NET server can use the bridge component to route messages
            received via the message handler.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener">
            <summary>
            WebSocket server.
            </summary>
            <remarks>
            <example>
            The following example implements a simple service echoing the incoming message back to the client.
            <code>
            using System;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace EchoService
            {
               class Program
               {
                   static void Main(string[] args)
                   {
                       WebSocketListener aService = new WebSocketListener(new Uri("ws://127.0.0.1:8045/Echo/"));
            
                       aService.StartListening(client =>
                       {
                           WebSocketMessage aMessage;
                           while ((aMessage = client.ReceiveMessage()) != null)
                           {
                               object aData;
                               if (aMessage.IsText)
                               {
                                   aData = aMessage.GetWholeTextMessage();
                               }
                               else
                               {
                                   aData = aMessage.GetWholeMessage();
                               }
            
                               // Send echo.
                               client.SendMessage(aData);
                           }
                       });
            
                       Console.WriteLine("WebSocket service is listening. Press Enter to stop.");
                       Console.ReadLine();
            
                       aService.StopListening();
                   }
               }
            }
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.#ctor(System.Uri)">
            <summary>
            Construct websocket service.
            </summary>
            <param name="webSocketUri">service address. Provide port number too.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.#ctor(System.Uri,Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory)">
            <summary>
            Construct websocket service.
            </summary>
            <param name="webSocketUri">service address. Provide port number too.</param>
            <param name="securityFactory">
            Factory allowing SSL communication. <see cref="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory"/>
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.StartListening(System.Action{Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext})">
            <summary>
            Starts listening.
            </summary>
            <remarks>
            To handle connected clients the connectionHandler delegate is called. The connectionHandler delegate
            is called in parallel from multiple threads as clients are connected.
            </remarks>
            <param name="connectionHandler">callback delegate handling incoming connections. It is called 
            from multiple threads.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.StopListening">
            <summary>
            Stops listening and closes all open connections with clients.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.IsListening">
            <summary>
            Returns true if the service is listening.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.WebSocketListenerImpl">
            <summary>
            Wraps the the implementation of the path listener to a separate class because PathListenerProviderBase
            shall be visible only internally.
            In addition, the documentation needs to be generated for WebSocketListener - therefore all methods
            would have to be overriden to have its own specific help description.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.PathListenerProviderBase`1">
            <summary>
            Base class representing listeners listening on IP address, port and path.
            E.g. websockets and http
            </summary>
            <typeparam name="_TClientContext"></typeparam>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.IHostListenerFactory">
            <summary>
            Instantiates the host listener for the given IP address and port.
            </summary>
            <remarks>
            The host listener then processes the TCP connection and parses out the path.
            Then it forwards the message to the correct path listener.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.IHostListenerFactory.CreateHostListener(System.Net.IPEndPoint,Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory)">
            <summary>
            Creates the host listener.
            </summary>
            <param name="address"></param>
            <param name="securityFactory"></param>
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.IHostListenerFactory.ListenerType">
            <summary>
            Returns the type of the of the host listener. The host listener is derived from HostListenerBase.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpInputChannelBase.HandleConnection(System.Net.Sockets.TcpClient)">
            <summary>
            The method is called in a separate thread when the connection is established.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.NamespaceDoc">
            <summary>
            Functionality for encoding/decoding the low-level communication between communicating channels.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory">
            <summary>
            Implements the messaging factory extending the underlying messaging system by monitoring the connection
            between duplex output channel and duplex input channel.
            </summary>
            <remarks>
            When the connection is monitored, the duplex output channel periodically sends 'ping' messages
            to the duplex input channel and waits for responses.
            If the response comes within the specified timeout, the connection is open.
            <br/>
            On the receiver side, the duplex input channel waits for the 'ping' messages and monitors if the connected
            duplex output channel is still alive. If the 'ping' message does not come within the specified timeout,
            the particular duplex output channel is disconnected.
            <br/><br/>
            Notice, the output channel and the input channel do not maintain an open connection.
            Therefore, the monitored messaging is not applicable for them. The implementation of this factory just uses
            the underlying messaging to create them.
            <br/><br/>
            <b>Note</b>
            Channels created by monitored messaging factory cannot communicate with channels, that were not created
            by monitored factory. E.g. the channel created with the monitored messaging factory with underlying TCP
            will not communicate with channels created directly with TCP messaging factory. The reason is, the
            communicating channels must understand the 'ping' communication.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            It uses <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The duplex output channel will check the connection with the 'ping' once per second and the response must be received within 2 seconds.
            Otherwise the connection is closed.<br/>
            The duplex input channel expects the 'ping' request at least once per 2s. Otherwise the duplex output
            channel is disconnected.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory from specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
            <param name="serializer">serializer used to serialize 'ping' messages</param>
            <param name="pingFrequency">how often the duplex output channel pings the connection</param>
            <param name="pingResponseTimeout">
            For the duplex output channel: the maximum time, the response for the ping must be received
            <br/>
            For the duplex input channel: the maximum time within the ping for the connected duplex output channel
            must be received.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the input channel.
            </summary>
            <remarks>
            Since the output channel communicates oneway and does not maintain the open connection,
            the monitoring of the connection is not applicable.
            Therefore, the implementation of the method just uses the underlying messaging to create the output channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel.
            </summary>
            <remarks>
            Since the input channel communicates oneway and does not maintain the open connection,
            the monitoring of the connection is not applicable.
            Therefore, the implementation of the method just uses the underlying messaging to create the input channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            The channel also regularly checks if the connection is available. It sends 'ping' messages and expect 'ping' responses
            within the specified timeout. If the 'ping' response does not come within the specified timeout, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> is invoked.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            The channel also regularly checks if the connection is available. It sends 'ping' messages and expect 'ping' responses
            within the specified timeout. If the 'ping' response does not come within the specified timeout, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> is invoked.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">response receiver id of the channel</param>
            <returns>composit duplex output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            It also checks if the duplex output channel is still connected. It expect, that every connected duplex output channel
            sends regularly 'ping' messages. If the 'ping' message from the duplex output channel is not received within the specified
            timeout, the duplex output channel is disconnected. The event <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected"/>
            is invoked.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex input channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexInputChannel"/></returns>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase">
            <summary>
            The abstract class implementing the interface for attaching multiple input channels.
            The class also contains functionality to send (forward) messages via duplex output channels - the duplex input channel
            from the message is forwarded is remembered.
            The duplex output channels used for forwarding are not attached but dynamically created as they are needed.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.CloseConnections(System.Collections.Generic.IEnumerable{Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TConnection})">
            <summary>
            Closes given connections with client duplex output channel.
            </summary>
            <param name="connections"></param>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TConnection">
            <summary>
            Represents the connection between the duplex input channel and the duplex output channel.
            So when the response from the duplex output channel is received it can be forwarded to attached the
            duplex input channel with the correct response receiver id.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TDuplexInputChannelContext">
            <summary>
            The context of the duplex input channel consists of the attached duplex input channel and
            it also can contain the list of duplex output channels used to forward the message.
            E.g. The DuplexDispatcher receives the message from the attached duplex input channel and then forwards
            it to all duplex output channels.
            E.g. The DuplexChannelWrapper receives the message from the attached duplex input channel then wrapps
            the message and sends it via the duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.ResponseMessageFragment`1">
            <summary>
            Data used for the typed sequenced response message fragment.
            The data is used to send response message from a duplex input channel to a duplex output channel.
            </summary>
            <typeparam name="_ResponseType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ResponseMessageFragment`1.#ctor">
            <summary>
            Default constructor for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ResponseMessageFragment`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>
            Constructor creating the typed message fragment from the given input parameters.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.ResponseMessageFragment`1.FragmentData">
            <summary>
            Returns serialized fragment value.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.CryptoSerializerProvider.Serialize``1(``0,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Serializes data to the object.
            The returned object is type of byte[]. Output bytes are encrypted.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <param name="algorithm">algorithm used to encrypt the serialized data</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.CryptoSerializerProvider.Deserialize``1(System.Object,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Encrypted data to be deserialized.</param>
            <param name="algorithm">algorithm used to decrypt data before deserialization</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.BinarySerializer">
            <summary>
            Implements the serialization/deserialization to/from sequence of bytes.
            </summary>
            <remarks>
            The serializer internally uses BinaryFormatter provided by .Net.
            The data is serialized in the binary format.
            <br/><br/>
            This serializer is not supported in Silverlight and Windows Phone 7 platforms.
            <br/>
            <example>
            Serialization and deserialization example.
            <code>
            // Some class to be serialized.
            [Serializable]
            public class MyClass
            {
                public int Value1 { get; set; }
                public string Value2 { get; set; }
            }
            
            ...
            
            MyClass c = new MyClass;
            c.Value1 = 10;
            c.Value2 = "Hello World.";
            
            ...
            
            // Serialization
            BinarySerializer aSerializer = new BinarySerializer();
            object aSerializedObject = aSerializer.Serialize&lt;MyClass&gt;(c);
            
            ...
            
            // Deserialization
            BinarySerializer aSerializer = new BinarySerializer();
            object aDeserializedObject = aSerializer.Deserialize&lt;MyClass&gt;(aSerializedObject);
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.BinarySerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the sequnce of bytes, byte[].
            </summary>
            <remarks>
            It internally BinaryFormatter provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.BinarySerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <remarks>
            It internally BinaryFormatter provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">the sequence of bytes (byte[]), to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IDuplexRouter">
            <summary>
            Declares the duplex router.
            </summary>
            <remarks>
            The duplex router has attached more duplex input channels and uses more duplex output channels.<br/>
            When it receives some message via the duplex input channel, it forwards the message to all configured duplex output channels.<br/>
            This router is bidirectional. Therefore, it can forward messages and also route back response messages from receivers.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.AddConnection(System.String,System.String)">
            <summary>
            Adds the connection configuration to the router. It means when the duplex input channel receives a
            message then the message will be forwarded to the specified duplex output channel too.
            </summary>
            <param name="duplexInputChannelId"></param>
            <param name="duplexOutputChannelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.RemoveConnection(System.String,System.String)">
            <summary>
            Removes the connection configuration from the router.
            </summary>
            <param name="duplexInputChannelId"></param>
            <param name="duplexOutputChannelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.RemoveAllConnections">
            <summary>
            Removes all configurations from the router.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.NamespaceDoc">
            <summary>
            Functionality for sending/receiving more message types via one channel.
            </summary>
            <remarks>
            The channel wrapper and unwrapper are components allowing to send/receive more messages via one channel.
            The user code then does not need to implement if ... then code recognizing particular messages.
            It also can help to save channel resources. E.g. application can open only limited number of connections.
            The channel wrapper has attached more input channels and one output channel.
            The symmetric component the channel unwrapper has attached one input channel and more output channels.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelUnwrapper.OnResponseReceiverDisconnected(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs)">
            <summary>
            The method is called when the response receiver is disconnected.
            The method clears all connections related to the disconnected receiver.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelUnwrapper.OnResponseMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            Method is called when a response is received from the duplex output channel.
            It wrapps the response and sends the wrapped response to the correct response receiver as the response.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Bridge.BridgeFactory">
             <summary>
             Implements the factory to create Bridge and Duplex Bridge.
             </summary>
             <remarks>
             Bridge is intended to connect a different mechanism for receiving messages with the Eneter Framework.
             E.g. If ASP.NET server receives messages from its Silverlight client via the generic handler (*.ashx file),
             the bridge can be used to send such messages to their receivers inside the ASP.NET application.
             <example>
             The example shows receiving messages via the generic handler in ASP.NET service and
             using the bridge component to forward these messagas to receivers.
             <code>
             Instantiate the bridge in Global.asax.cs
             
              protected void Application_Start(object sender, EventArgs e)
              {
                  // MessagingSystem that will be used by the Silverlight-ASP messaging "bridge"
                  myServerMessagingSystem = new SynchronousMessagingSystemFactory();
                  
                 // Create the duplex input channel for the broker.
                 // Note: The broker will listen to this channel.
                  IDuplexInputChannel aBrokerDuplexInputChannel = myServerMessagingSystem.CreateDuplexInputChannel("BrokerChannel");
            
                 // Create broker.
                 // Because we communicate with Silverlight it must be XmlSerialization.
                 IDuplexBrokerFactory aBrokerFactory = new DuplexBrokerFactory(new XmlStringSerializer());
                 myBroker = aBrokerFactory.CreateBroker();
                 myBroker.AttachDuplexInputChannel(aBrokerDuplexInputChannel);
            
                 // Create the duplex output channel for the client that will send notifications.
                 IDuplexOutputChannel aClientDuplexOutputChannel = myServerMessagingSystem.CreateDuplexOutputChannel("BrokerChannel");
            
                 // Create sender of notification messages.
                 myBrokerClient = aBrokerFactory.CreateBrokerClient();
                 myBrokerClient.AttachDuplexOutputChannel(aClientDuplexOutputChannel);
            
                 // Create bridge to connect Silverligh with Asp
                 IBridgeFactory aBridgeFactory = new BridgeFactory();
                 myBridge = aBridgeFactory.CreateDuplexBridge(myServerMessagingSystem, "BrokerChannel");
            
                 // Store the bridge to be used from MessagingHandler.ashx.cs
                 Application["Bridge"] = myBridge;
                 
                 .......
              }     
             </code>
             
             <code>
             Then the using the bridge to forward received messages:
             
             // Handles messaging communication with Silverlight clients.
             public class MessagingHandler : IHttpHandler
             {
                 public void ProcessRequest(HttpContext context)
                 {
                     context.Application.Lock();
             
                     // Get the bridge to the broker and forward the message to the messaging system
                     // connected with the bridge.
                     IDuplexBridge aBridge = context.Application["Bridge"] as IDuplexBridge;
                     aBridge.ProcessRequestResponse(context.Request.InputStream, context.Response.OutputStream);
             
                     context.Application.UnLock();
                 }
             
                 public bool IsReusable { get { return false; } }
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Bridge.BridgeFactory.#ctor">
            <summary>
            Constructs the factory that will create bridges with default parameters.
            </summary>
            <remarks>
            Requester inactivity timeout is set to int.MaxValue and
            the maximum size of the response is int.MaxValue.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Bridge.BridgeFactory.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs the factory with specified inactivity timeout and specified maximum size of the
            response message. 
            </summary>
            <remarks>
            If the response message should be bigger then the message will be sent on more times.
            This is to avoid that the sending of one big message will degradate the performance. <br/>
            These settings are valid only for the Duplex Bridge.
            </remarks>
            <param name="duplexRequesterInactivityTimeout">
            The inactivity timeout is used to recognize if the client is connected. If the client does not
            poll or send the message longer than the specified inactivity time, the client is considered to be disconnected.
            </param>
            <param name="maxSizeOfResponse">
            The maximum size of the response. E.g. If the bridge has collected 500 response messages which size is together 1MB
            and the maximum response size is set to 300KB, then the response will contain messages until the specified size is exceeded
            (including the first message that exceeds the limit). The messages that were not included in the response will be responded
            the next time.<br/>
            Notice, this parameter is applicable only for DuplexBridge.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Bridge.BridgeFactory.CreateBridge">
            <summary>
            Creates the bridge to transfer one-way messages.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Bridge.BridgeFactory.CreateDuplexBridge(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,System.String)">
            <summary>
            Creates the bridge to transfer messages in both directions (request-response).
            </summary>
            <param name="messagingSystemFactory"></param>
            <param name="channelId"></param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory">
            <summary>
            The factory class creating the security stream allowing authentication as client and encrypted communication
            based on SSL protocol.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory.#ctor(System.String)">
            <summary>
            Constructs the factory for the case where only the server identity is verifyied.
            </summary>
            <param name="hostName">The host the client wants to communicate with. The host name must match with the certificate name.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory.#ctor(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection)">
            <summary>
            Constructs the factory for the case where server identity and also the client identity are verifyied.
            </summary>
            <param name="hostName">The host the client wants to communicate with. The host name must match with the certificate name.</param>
            <param name="clientCertificates">List of certificates provided by the client. If null, the client is not verified.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory.#ctor(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <summary>
            Constructs the factory for the case where server identity and also the client identity can be verifyied.
            </summary>
            <param name="hostName">The host the client wants to communicate with. The host name must match with the certificate name.</param>
            <param name="certificates">List of certificates provided by the client. If null, the client is not verified.</param>
            <param name="userCertificateValidationCallback">User provided delegate for validating the certificate supplied by the remote party.</param>
            <param name="userCertificateSelectionCallback">User provided delegate for selecting the certificate used for authentication.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory.CreateSecurityStreamAndAuthenticate(System.IO.Stream)">
            <summary>
            Creates the security stream and performs the authentication as client.
            </summary>
            <param name="source">The stream wrapped by the security stream.</param>
            <returns>Security stream of type SslStream.</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.ListeningInstance.StartListening">
            <summary>
            Starts the thread where the instance loops trying to serve client requests.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.ListeningInstance.SetStopListeningFlag">
            <summary>
            Sets the stop listening flag before call StopListening().
            The problem is that the StopListening() stops some listening instance - not neccessarily this one.
            Therefore, we let know to all of them that the sop will come.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.ListeningInstance.StopListening(System.String,System.Int32)">
            <summary>
            Stops listening of one instance listening to this pipe.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.ListeningInstance.DoListening">
            <summary>
            Listens to client requests and put them to the queue from where the working thread takes them
            and notifies the call-backs the pipe input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel">
            <summary>
            Declares the reliable duplex output channel.
            </summary>
            <remarks>
            It behaves like <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel"/> and can also be used everywhere where <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel"/>
            is required.<br/>
            In addition, the reliable duplex output channel provides events <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageDelivered"/> and <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageNotDelivered"/>.
            The method <see cref="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.SendMessage(System.Object)"/> returns the message id.
            <br/><br/>
            The reliable duplex output channel can send messages to <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            It cannot send messages to <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel"/>.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.SendMessage(System.Object)">
            <summary>
            Sends the message to the reliable duplex output channel.
            </summary>
            <param name="message">message</param>
            <returns>id of the message</returns>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageDelivered">
            <summary>
            The event is invoked when the message was delivered to the reliable duplex input channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageNotDelivered">
            <summary>
            The event is invoked if the message was not delivered until the specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1">
            <summary>
            The event when the typed sequenced message is received.
            </summary>
            <typeparam name="_MessageDataType">message type</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.#ctor(Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedMessageFragment{`0})">
            <summary>
            Constructs the event.
            </summary>
            <param name="dataFragment">message fragment</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event from the exception.
            </summary>
            <param name="receivingError">error detected during receiving of the message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.SequenceId">
            <summary>
            Returns the sequence identifier.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.IsSequenceCompleted">
            <summary>
            Returns true if the sequence is completed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.MessageData">
            <summary>
            Returns message inputData of the specified type.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            E.g. during the deserialization of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessagesFactory">
            <summary>
            The interface declares the factory to create duplex typed sequenced message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessagesFactory.CreateDuplexTypedSequencedMessageSender``2">
            <summary>
            Creates the duplex typed sequenced message sender.
            </summary>
            <typeparam name="_ResponseType">The type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">The type of sending messages.</typeparam>
            <returns>duplex typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessagesFactory.CreateDuplexTypedSequencedMessageReceiver``2">
            <summary>
            Creates the duplex typed sequences message receiver.
            </summary>
            <typeparam name="_ResponseType">The type of sending response messages.</typeparam>
            <typeparam name="_RequestType">The type of receiving messages.</typeparam>
            <returns>duplex typed sequenced message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageSender`2">
            <summary>
            The interface declares the duplex sender that sends sequences of strongly typed messages.
            The sender is able to send sequences of typed messages and receive sequences of typed response messages.
            </summary>
            <typeparam name="_ResponseType">The type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">The type of sending messages.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageSender`2.SendMessage(`1,System.String,System.Boolean)">
            <summary>
            Sends typed message.
            </summary>
            <param name="message">message</param>
            <param name="sequenceId">identifies the sequence the message is part of</param>
            <param name="isSequenceCompleted">true - indicates the sequence is completed</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageSender`2.ResponseReceived">
            <summary>
            The event is invoked when the response message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2">
            <summary>
            The interface declares the command proxy.
            The command proxy is able to send the request to execute some activity in the respective command.
            The command proxy is also able to request pause, resume or cancel.
            It receive response messages from the command.
            </summary>
            <typeparam name="_ReturnDataType">Type of return data.</typeparam>
            <typeparam name="_InputDataType">Type of input data.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Pause(System.String)">
            <summary>
            Sends the pause request to the command.
            </summary>
            <param name="commandId">identifies the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Resume(System.String)">
            <summary>
            Sends the resume request to the command.
            </summary>
            <param name="commandId">identifies the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Cancel(System.String)">
            <summary>
            Sends the cancel request to the command.
            </summary>
            <param name="commandId">identifies the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Execute(System.String)">
            <summary>
            Sends the execute request to the command.
            </summary>
            <param name="commandId">identifies particular command e.g. when the proxy invokes more commands</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Execute(System.String,`1)">
            <summary>
            Sends the execute request to the command.
            </summary>
            <param name="commandId">identifies particular command e.g. when the proxy invokes more commands</param>
            <param name="inputData">input data</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Execute(System.String,`1,System.String,System.Boolean)">
            <summary>
            Sends the execute request to the command.
            The input data is sent as a sequence.
            </summary>
            <param name="commandId">identifies particular command e.g. when the proxy invokes more commands</param>
            <param name="inputData">input data</param>
            <param name="sequenceId">input data sequence identifier</param>
            <param name="isSequenceCompleted">true - if the sequence is completed</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.CommandResponseReceived">
            <summary>
            The event is invoked when the response message from the command was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ECommandState">
            <summary>
            Enumerates possible commands states.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.NotApplicable">
            <summary>
            The state is not applicable.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.NotStarted">
            <summary>
            The command was not executed yet.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.InProgress">
            <summary>
            The execute request is in the progress.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.Paused">
            <summary>
            The execute request is paused.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.Completed">
            <summary>
            The execute request is completed.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.Canceled">
            <summary>
            The execute request is canceled.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.Failed">
            <summary>
            The execute request failed.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.CommandProxy`2.myDuplexOutputChannelId">
            <summary>
            This is used only for trace purposes.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1">
            <summary>
            Implements the thread that has the message queue.
            If a message is put to the queue, the thread removes it from the queue and calls a user defined
            method to handle it.
            </summary>
            <typeparam name="_MessageType">type of the message processed by the thread</typeparam>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.#ctor">
            <summary>
            Constructs the working thread.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.#ctor(System.String)">
            <summary>
            Constructs the working thread with the specified name.
            </summary>
            <param name="workingThreadName">name of the thread</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.RegisterMessageHandler(System.Action{`0})">
            <summary>
            Registers the method handling messages from the queue and starts the thread reading messages from the queue.
            </summary>
            <param name="messageHandler">Callback called from the working thread to process the message</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the message handler is already registered.</exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.UnregisterMessageHandler">
            <summary>
            Unregisters the method handling messages from the queue and stops the thread reading messages.
            If the thread does not stop within 5 seconds it is aborted.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.EnqueueMessage(`0)">
            <summary>
            Puts the message to the queue.
            </summary>
            <param name="message">message</param>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.myMessageHandler">
            <summary>
            Handler called to process the message from the queue.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher">
            <summary>
            Declares the duplex dispatcher.
            </summary>
            <remarks>
            The duplex dispatcher has attached more duplex input channels and uses more duplex output channels.<br/>
            When it receives some message via the duplex input channel it forwards the message to all duplex output channels.<br/>
            The duplex dispatcher allows the bidirectional communication. It means, receivers to whom the message was forwarded can
            sand back response messages. Therefore, the sender can get response messages from all receivers.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.AddDuplexOutputChannel(System.String)">
            <summary>
            Adds the duplex output channel id to the dispatcher. The dispatcher will then start to forward
            the incoming messages also to this channel.
            </summary>
            <param name="channelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.RemoveDuplexOutputChannel(System.String)">
            <summary>
            Removes the duplex output channel from the dispatcher.
            </summary>
            <param name="channelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.RemoveAllDuplexOutputChannels">
            <summary>
            Removes all duplex output channels from the dispatcher.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Bridge.IBridge">
            <summary>
            Declares the bridge for one-way messaging.
            </summary>
            <remarks>
            The bridge allows to connect applications in case the receiving application uses some different
            mechanism for receiving messages.<br/>
            E.g. The ASP server uses message handlers (*.ashx files). Therefore, if the ASP server wants to receive
            messages from the Silverlight application, then the ASP server can use the bridge component to route messages
            received via the message handler.
            <br/>
            The one-way bridge forwards incoming messages to the real receiver.<br/>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Bridge.IBridge.SendMessage(System.IO.Stream)">
            <summary>
            Forwards the message to the real receiver.
            </summary>
            <param name="message">message stored in the stream</param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transferring messages via TCP.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpInputChannel.HandleConnection(Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpRequestContext)">
            <summary>
            Processes the Http requests.
            It gets the message and puts it to the queue. The message is then removed from the queue by
            the working thread that notifies the subscriber.
            </summary>
            <param name="httpClientContext"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter">
            <summary>
            Implements encoding/decoding of low-level messages into eneter format.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1">
            <summary>
            Declares functionality to encode and decode messages used for the communication between channels. 
            </summary>
            <typeparam name="T">type of encoded data. It can be byte[] or String.</typeparam>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter">
            <summary>
            Declares functionality to encode and decode messages used for the communication between channels.
            </summary>
            <remarks>
            Encoded messages are presented as type of object. This interface is used if it is not needed to know
            if the encoded messages are byte[] or string.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Encodes the open connection request message.
            </summary>
            <remarks>
            The message is used by the duplex output channel to open the connection with the duplex input channel.
            </remarks>
            <param name="responseReceiverId">id of the client opening the connection.</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Encodes the close connecion request message.
            </summary>
            <remarks>
            The message is used by the duplex output channel or duplex input channel to close the connection.
            </remarks>
            <param name="responseReceiverId">id of the client that wants to disconnect or that will be disconnected</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeMessage(System.String,System.Object)">
            <summary>
            Encodes a message or a response message.
            </summary>
            <remarks>
            The message is used by output channel or duplex output channel to send messages or
            by duplex input channel to send response messages.
            </remarks>
            <param name="responseReceiverId">client id. It is empty string in case of output channel.</param>
            <param name="message">message serialized message to be sent.</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodePollRequest(System.String)">
            <summary>
            Encodes message used by some duplex (e.g. HTTP duplex output channel) to send the poll request.
            </summary>
            <param name="responseReceiverId">id of the client polling messages</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes message from the stream.
            </summary>
            <param name="readStream">stream to be read</param>
            <returns>decoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.DecodeMessage(System.Object)">
            <summary>
            Decodes message from the given object.
            </summary>
            <param name="readMessage">reference to the object.</param>
            <returns>decoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Encodes the open connection request message.
            </summary>
            <remarks>
            The message is used by the duplex output channel to open the connection with the duplex input channel.
            </remarks>
            <param name="responseReceiverId">id of the client opening the connection.</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Encodes the close connecion request message.
            </summary>
            <remarks>
            The message is used by the duplex output channel or duplex input channel to close the connection.
            </remarks>
            <param name="responseReceiverId">id of the client that wants to disconnect or that will be disconnected</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.EncodeMessage(System.String,System.Object)">
            <summary>
            Encodes a message or a response message.
            </summary>
            <remarks>
            The message is used by output channel or duplex output channel to send messages or
            by duplex input channel to send response messages.
            </remarks>
            <param name="responseReceiverId">client id. It is empty string in case of output channel.</param>
            <param name="message">message serialized message to be sent.</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.EncodePollRequest(System.String)">
            <summary>
            Encodes message used by some duplex (e.g. HTTP duplex output channel) to send the poll request.
            </summary>
            <param name="responseReceiverId">id of the client polling messages</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes message from the stream.
            </summary>
            <param name="readStream">stream to be read</param>
            <returns>decoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.DecodeMessage(`0)">
            <summary>
            Decodes message from the given object.
            </summary>
            <param name="readMessage">reference to the object.</param>
            <returns>decoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Encodes open connection request.
            </summary>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Encodes close connection request.
            </summary>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeMessage(System.String,System.Object)">
            <summary>
            Encodes a message or a response message.
            </summary>
            <param name="responseReceiverId">client id</param>
            <param name="message">the serialized content of the message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodePollRequest(System.String)">
            <summary>
            Encodes poll request.
            </summary>
            <remarks>
            Polling is used e.g. in HTTP messaging to get response messages from the service.
            </remarks>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes a message or a response message from the stream.
            </summary>
            <param name="readStream">stream containing the low-level message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.DecodeMessage(System.Byte[])">
            <summary>
            Decodes a message or a response message from the byte[].
            </summary>
            <param name="readMessage">source of the low-level message</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.SentMessageItem">
            <summary>
            Represents the message that was sent.
            It stores the message id and the time when the message was sent.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage">
            <summary>
            The message internally used for the reliable communication between reliable duplex output channel
            and reliable duplex input channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.#ctor">
            <summary>
            Default constructor for serializing purposes.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.#ctor(System.String)">
            <summary>
            Constructs the acknowledge message.
            Acknowledge confirms, the message was delivered.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.#ctor(System.String,System.Object)">
            <summary>
            Constructs the reliable message that contains the message to be sent.
            </summary>
            <param name="messageId"></param>
            <param name="message"></param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.MessageType">
            <summary>
            Type of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.MessageId">
            <summary>
            In case of the message type Message - unique id of the reliable message.
            In case of the message type Acknowledge - id of the message, that is acknowledged.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.Message">
            <summary>
            In case of the message type Message - the message that shall be sent reliably.
            In case of the message type Acknowledge - not used.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.EMessageType">
            <summary>
            Indicates the purpose of the message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.EMessageType.Message">
            <summary>
            The reliable message contains a message that shall be notified via the event.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.EMessageType.Acknowledge">
            <summary>
            The reliable message is the acknowledgement, that the message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType">
            <summary>
            Type of the message sent by the monitor duplex output channel or monitor dupolex input channel.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType.Ping">
            <summary>
            Indicates, it is the ping message or ping response.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType.Message">
            <summary>
            Indicates, it is a message or a response message containing data. 
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage">
            <summary>
            The message used by the monitor duplex output channel or monitor duplex input channel for the communication.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.#ctor">
            <summary>
            Constructs the message. This constructor is used by the Xml serializer for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.#ctor(Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType,System.Object)">
            <summary>
            Constructs the message from specified parameters.
            </summary>
            <param name="messageType">type of the message, ping or regular message</param>
            <param name="messageContent">message content, in case of ping this parameter is not used</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.MessageType">
            <summary>
            Type of the message. Ping or regular message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.MessageContent">
            <summary>
            Message. In case of the 'ping', this property is null.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.NamespaceDoc">
            <summary>
            Functionality to send and receive messages as strongly typed data.
            </summary>
            <remarks>
            Typed message senders and typed message receivers allows to send and receive messages as declared types.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.NamespaceDoc">
            <summary>
            Functionality to send and receive simple text messages.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ECommandRequest">
            <summary>
            Enumerates requests the command can receive.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandRequest.Execute">
            <summary>
            The command is asked to execute the activity.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandRequest.Pause">
            <summary>
            The command is asked to pause.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandRequest.Resume">
            <summary>
            The command is asked to resume.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandRequest.Cancel">
            <summary>
            The command is asked to cancel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.ErrorHandler">
            <summary>
            Internal helper class to trace typical messags.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IRouterFactory">
            <summary>
            Declares the factory creating the one-way router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IRouterFactory.CreateRouter">
            <summary>
            Creates the router.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.LoadBalancer.RoundRobinBalancerFactory">
            <summary>
            Factory that creates the load balancer based on Round-Robin algorithm.
            </summary>
            <remarks>
            The Round-Robin balancer distributes the incoming requests equally to all maintained receivers.
            It means, the balancer maintains which receiver was used the last time. Then, when a new request comes,
            the balancer picks the next receiver in the list up. If it is at the end, then it starts from the beginning.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.RoundRobinBalancerFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            COnstructs the factory.
            </summary>
            <param name="duplexOutputChannelsFactory">
            messaging system used to create duplex output channels that will be used for the communication with
            receivers.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.RoundRobinBalancerFactory.CreateLoadBalancer">
            <summary>
            Creates the load balancer using the Round-Robin algorithm.
            </summary>
            <returns>load balancer</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient">
            <summary>
            WebSocket client.
            </summary>
            <remarks>
            Represents the client for the websocket communication.
            <example>
            The following example shows how to communicate with a websocket server.
            <code>
            WebSocketClient aClient = new WebSocketClient("ws://127.0.0.1:8045/MyService/");
            
            // Subscribe to receive messages.
            aClient.MessageReceived += OnResponseMessageReceived;
            
            // Open the connection.
            aClient.OpenConnection();
            
            // Send a text message.
            aClient.SendMessage("Hello.");
            
            ....
            
            // Handler of response messages.
            void OnResponseMessageReceived(object sender, WebSocketMessage e)
            {
                // Read the whole text message.
                if (e.IsText)
                {
                    string aMessage = e.GetWholeTextMessage();
                    ...
                }
            }
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.#ctor(System.Uri)">
            <summary>
            Constructs the websocket client.
            </summary>
            <param name="uri">websocket uri address. Provide port number too. e.g. ws://127.0.0.1:8055/myservice/<br/>
            You can also specify the query that can be used to pass some open connection related parameters.
            e.g. ws://127.0.0.1:8055/myservice/?param1=10&amp;param2=20
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.#ctor(System.Uri,Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory)">
            <summary>
            Constructs the websocket client.
            </summary>
            <param name="uri">websocket uri address. Provide port number too. e.g. ws://127.0.0.1:8055/myservice/<br/>
            You can also specify the query that can be used to pass some open connection related parameters.
            e.g. ws://127.0.0.1:8055/myservice/?param1=10&amp;param2=20
            </param>
            <param name="clientSecurityFactory">
            Factory allowing SSL communication. <see cref="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory"/>
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.OpenConnection">
            <summary>
            Opens connection to the websocket server.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.CloseConnection">
            <summary>
            Closes connection with the webscocket server.
            </summary>
            <remarks>
            It sends the close message to the service and closes the underlying tcp connection.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.SendMessage(System.Object)">
            <summary>
            Sends message to the server.
            </summary>
            <remarks>
            The message must be type of string or byte[].
            If the type is string then the message is sent as the text message via text frame.
            If the type is byte[] the message is sent as the binary message via binary frame.
            </remarks>
            <param name="data">message to be sent. Must be byte[] or string.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.SendMessage(System.Object,System.Boolean)">
            <summary>
            Sends message to the server. Allows to send the message via multiple frames.
            </summary>
            <remarks>
            The message must be type of string or byte[].
            If the type is string then the message is sent as the text message via text frame.
            If the type is byte[] the message is sent as the binary message via binary frame.<br/>
            <br/>
            It allows to send the message in multiple frames. The server then can receive all parts separately
            using WebSocketMessage.InputStream or as a whole message using WebSocketMessage.GetWholeMessage().
            <example>
            The following example shows how to send 'Hello world.' in three parts.
            <code>
                ...
                
                // Send the first part of the message.
                client.SendMessage("Hello ", false);
                
                // Send the second part.
                client.SendMessage("wo", false);
                
                // Send the third final part.
                client.SendMessage("rld.", true);
                
                ...
            </code>
            </example>
            </remarks>
            <param name="data"></param>
            <param name="isFinal"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.SendPing">
            <summary>
            Pings the service. According to websocket protocol, pong should be responded.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.SendPong">
            <summary>
            Sends unsolicited pong to the service.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.ConnectionOpened">
            <summary>
            Event is invoked when the connection is open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.ConnectionClosed">
            <summary>
            Event is invoked when the connection is closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.PongReceived">
            <summary>
            Event is invoked when the pong is received. E.g. when the server responded ping.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.MessageReceived">
            <summary>
            The event is invoked when a data message from server is received.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.SendTimeout">
            <summary>
            Sets or gets the send timeout.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.Uri">
            <summary>
            Returns address of websocket server.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.HeaderFields">
            <summary>
            Allows to get and set header-fields which shall be sent in open connection request.
            </summary>
            <remarks>
            It allows to add your custom header fields that shell be sent in the open connection request.
            The header-field Sec-WebSocket-Key is generated and added when OpenConnection() is called.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.IsConnected">
            <summary>
            Returns true if the connection to the server is open.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.LocalEndPoint">
            <summary>
            Returns the IP address of the client used for the communication with the server.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory">
            <summary>
            Implements the messaging system delivering messages to the particular working thread.
            </summary>
            <remarks>
            Each input channel is represented by its own working thread removing messages from the queue and processing them
            one by one.
            <br/><br/>
            Different instances of ThreadMessagingSystemFactory are independent and so they
            are different messaging systems. Therefore if you want to send/receive a message with this messaging system
            then output and input channels must be created by the same instance of ThreadMessagingSystemFactory.
            <br/><br/>
            Notice, the messages are always received in one particular working thread, but the notification events e.g. connection opened
            are invoked in a different thread.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.#ctor">
            <summary>
            Constructs thread based messaging factory.
            </summary>
            <remarks>
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs thread based messaging factory.
            </summary>
            <remarks>
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </remarks>
            <param name="protocolFormatter">low-level message formatter for the communication between channels.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the specified input channel via the message queue processed by the working thread.
            </summary>
            <remarks>
            The output channel can send messages only to the input channel and not to the duplex input channel.
            </remarks>
            <param name="channelId">Identifies the receiving input channel.</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel via the working thread.
            </summary>
            <remarks>
            The input channel can receive messages only from the output channel and not from the duplex output channel.
            </remarks>
            <param name="channelId">Identifies this input channel.</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the working thread.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the working thread.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using the working thread.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">Identifies this duplex input channel.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpInputChannel.HandleConnection(System.Net.Sockets.TcpClient)">
            <summary>
            The method is called in a separate thread when the connection is established.
            </summary>
            <param name="tcpClient"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeInputChannel.MessageHandler(Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage)">
            <summary>
            The method is called from the working thread. When a message shall be processed.
            Messages comming from the pipe from diffrent threads are put to the queue where the working
            thread removes them one by one and notify the subscribers on the input channel.
            Therefore the channel notifies always in one thread.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.NamespaceDoc">
            <summary>
            Interfaces representing the messaging system.
            </summary>
            <remarks>
            The messaging system is responsible for delivering messages from a sender to a receiver through communication channels.
            <br/><br/>
            For the one-way communication, the messaging system provides the output channel and the input channel.
            The output channel sends messages to the input channel with the same channel id.
            <br/><br/>
            For the bidirectional communication, the messaging system provides the duplex output channel and the duplex input channel.
            The duplex output channel sends messages to the duplex input channel with the same channel id and can receive response messages.
            The duplex input channel receives messages and can send back response messages.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.MessageIdEventArgs">
            <summary>
            The event arguments used for the notification whether the message was delivered or not delivered.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.MessageIdEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event arguments.
            </summary>
            <param name="messageId">id of the message</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.MessageIdEventArgs.MessageId">
            <summary>
            Returns id of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory">
            <summary>
            Extends the messaging system to work temporarily offline while the connection is not available.
            </summary>
            <remarks>
            The buffered messaging is intended to overcome relatively short time intervals when the connection is not available.
            It means, the buffered messaging is able to hide the connection is not available and work offline while
            trying to reconnect.<br/>
            If the connection is not available, the buffered messaging stores sent messages (and sent response messages)
            in the buffer and sends them when the connection is established.<br/>
            Buffered messaging also checks if the between duplex output channel and duplex input channel is active.
            If the connection is not used (messages do not flow between client and service) the buffered messaging
            waits the specified maxOfflineTime and then disconnects the client.
             
            Typical scenarios for buffered messaging:
            <br/><br/>
            <b>Short disconnections</b><br/>
            The network connection is unstable and can be anytime interrupted. In case of the disconnection, sent messages are stored
            in the buffer while the connection tries to be reopen. If the connection is established again,
            the messages are sent from the buffer.<br/>
            <br/>
            <b>Independent startup order</b><br/>
            The communicating applications starts in undefined order and initiates the communication. 
            The buffered messaging stores messages in the buffer while receiving application is started and ready to receive
            messages.<br/> 
            <br/>
            <b>Note:</b><br/>
            The buffered messaging does not require, that both communicating parts create channels with buffered messaging factory.
            It means, e.g. the duplex output channel created with buffered messaging with underlying TCP, can send messages
            directly to the duplex input channel created with just TCP messaging factory.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default parameters.
            </summary>
            <remarks>
            The maximum offline time will be set to 10 seconds.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,System.TimeSpan)">
            <summary>
            Constructs the factory from the specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
            <param name="maxOfflineTime">the max time, the communicating applications can be disconnected</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the input channel.
            </summary>
            <remarks>
            If the input channel is not available, the sent messages are stored in the buffer from where they are sent again
            when the input channel is available.
            If the message is not sent from the buffer (because the input channel is not available) within the specified offline time,
            the message is removed from the buffer.
            <br/>
            Note, when the message was successfully sent, it does not mean the message was delivered. It still can be lost on the way.
            <br/>
            The returned output channel is the composite channel. Therefore, if you need to reach underlying channels,
            you can cast it to <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeOutputChannel"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel.
            </summary>
            <remarks>
            The buffering functionality is not applicable for the input channel.
            Therefore, this method just uses the underlying messaging system to create the input channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            If the connection is not established, it puts sent messages to the buffer while trying to reconnect.
            Then when the connection is established, the messages are sent from the buffer.
            If the reconnect is not successful within the maximum offline time, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> and messages
            are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel"/> </returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            If the connection is not established, it puts sent messages to the buffer while trying to reconnect.
            Then when the connection is established, the message are sent from the buffer.
            If the reconnect is not successful within the maximum offline time, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> and messages
            are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">response receiver id of this duplex output channel</param>
            <returns>composit duplex output channel with the buffer <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            If the connection with the duplex output channel is not established, it puts sent response messages to the buffer.
            Then, when the duplex input channel is connected, the response messages are sent.
            If the duplex output channel does not connect within the specified maximum offline time, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected"/> is invoked and response messages are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex input channel with the buffer <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexInputChannel"/></returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer">
            <summary>
            Implements the serialization/deserialization to/from an xml string.
            The serializer is based on DataContractSerializer provided by .Net and it supports
            attributes (DataContract, DataMember, ...) specifying how data is serialized/deserialized.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.#ctor">
            <summary>
            Creates the serializer based on DataContractSerializer with default settings.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.#ctor(System.Func{System.Type,System.Runtime.Serialization.XmlObjectSerializer})">
            <summary>
            Creates the serializer that allows user to specify his own method to instantiate DataContractSerializer
            with desired settings.
            </summary>
            <param name="dataContractFactoryMethod">
            The factory method responsible for creation of DataContractSerializer.
            The factory method is called during the serialization or deserialization.<br/>
            The factory method can be called from more threads at the same time, so be sure, your factory method
            is thread safe.
            </param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the xml string.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>xml string</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data serialized in xml string.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.RouterFactory">
            <summary>
            Implements the factory creating the router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.RouterFactory.CreateRouter">
            <summary>
            Creates the router.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs">
            <summary>
            The event arguments of the received message from the broker.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.#ctor(System.String,System.Object)">
            <summary>
            Constructs the event from the input parameters.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.#ctor(System.Exception)">
            <summary>
            Constructs the event from the error detected during receiving of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.MessageTypeId">
            <summary>
            Returns type of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.Message">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory">
            <summary>
            Extends the communication by reliable messaging and monitored network connection.
            </summary>
            <remarks>
            This is the composite messaging system that consist of:
            <ol>
            <li>Reliable Messaging  --> confirmation, whether the sent messages were delivered.</li>
            <li>Monitored Messaging --> constantly monitores the connection</li>
            <li>Messaging System    --> responsible for sending and receiving messages</li>
            </ol>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default parameters.
            </summary>
            <remarks>
            The serializer for reliable messages and for 'ping' messages is set to <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The maximum time, the acknowledge message must be received is set to 11 seconds.
            The duplex output channel will check the connection with the 'ping' once per second and the response must be received within 2 seconds.
            Otherwise the connection is closed.<br/>
            The duplex input channel expects the 'ping' request at least once per 2s. Otherwise the duplex output
            channel is disconnected.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory with specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
            <param name="serializer">serializer used to serialize acknowledge messages and 'ping' messages</param>
            <param name="acknowledgeTimeout">the maximum time until the delivery of the message must be acknowledged</param>
            <param name="pingFrequency">how often the duplex output channel pings the connection</param>
            <param name="pingResponseTimeout">
            For the duplex output channel: the maximum time, the response for the ping must be received
            <br/>
            For the duplex input channel: the maximum time within the ping for the connected duplex output channel
            must be received.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the input channel.
            </summary>
            <remarks>
            Since the output channel communicates oneway and does not maintain the open connection,
            the reliable messaging and the connection monitoring are not applicable.
            Therefore, the implementation of the method just uses the underlying messaging to create the output channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel.
            </summary>
            <remarks>
            Since the input channel does not maintain the open connection and also does not send messages,
            the reliable messaging and the connection monitoring are not applicable.
            Therefore, the implementation of the method just uses the underlying messaging to create the input channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the reliable messaging and the connection monitoring.
            The connection monitoring constantly checks, if the connection is established. If the connection is broken,
            it notifies the connection was closed.<br/>
            The reliable messaging notifies whether the sent messages were delivered. See also <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the reliable messaging and the connection monitoring.
            The connection monitoring constantly checks, if the connection is established. If the connection is broken,
            it notifies the connection was closed.<br/>
            The reliable messaging notifies whether the sent messages were delivered. See also <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">
            the response receiver id used by the duplex input channel to distinguish between
            connected duplex output channels
            </param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            This duplex input channel provides the reliable messaging and the connection monitoring.
            The connection monitoring constantly checks, if the duplex output channel is still connected. If the
            duplex output channel does not 'ping' anymore, the duplex output channel is disconnected.<br/>
            The reliable messaging notifies whether the sent response messages were delivered. See also <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </remarks>
            <param name="channelId"></param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeOutputChannel">
            <summary>
            The interface declares the composit output channel.
            The composit output channel is the output channel that uses underlying output channel
            to send messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.ICompositeOutputChannel.UnderlyingOutputChannel">
            <summary>
            Returns the underlying output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessageSender`1">
            <summary>
            The interface declares the typed messsage sender that can send the messages in the sequence.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessageSender`1.SendMessage(`0,System.String,System.Boolean)">
            <summary>
            Sends the message of the specified type as a fragment of a sequence.
            The sequence identifier is an id for the sequence and must be same for all sent messages belonging to the sequence.
            </summary>
            <param name="message">message fragment</param>
            <param name="sequenceId">sequence identifier</param>
            <param name="isSequenceCompleted">flag indicating whether this is the last fragment of the message and sequence is completed</param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1">
            <summary>
            The event when a typed response message is received.
            </summary>
            <typeparam name="_ResponseMessageType">message type</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.#ctor(`0)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseMessage">response message</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event from the exception detected during receiving the response message.
            </summary>
            <param name="error"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.ResponseMessage">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns an exception detected during receiving the response message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringMessageEventArgs">
            <summary>
            The string message received event.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringMessageEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringMessageEventArgs.Message">
            <summary>
            Returns the received string message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer">
            <summary>
            Implements the serialization/deserialization to/from XmlString.
            </summary>
            <remarks>
            The serializer internally uses XmlSerializer provided by .Net.
            <example>
            Serialization and deserialization example.
            <code>
            // Some class to be serialized.
            public class MyClass
            {
                public int Value1 { get; set; }
                public string Value2 { get; set; }
            }
            
            ...
            
            MyClass c = new MyClass;
            c.Value1 = 10;
            c.Value2 = "Hello World.";
            
            ...
            
            // Serialization
            XmlStringSerializer aSerializer = new XmlStringSerializer();
            object aSerializedObject = aSerializer.Serialize&lt;MyClass&gt;(c);
            
            ...
            
            // Deserialization
            XmlStringSerializer aSerializer = new XmlStringSerializer();
            object aDeserializedObject = aSerializer.Deserialize&lt;MyClass&gt;(aSerializedObject);
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.#ctor">
            <summary>
            Creates the serializer based on XmlSerializer with default settings.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.#ctor(System.Func{System.Type,System.Xml.Serialization.XmlSerializer})">
            <summary>
            Creates the serializer that allows user to specify his own method instantiating XmlSerializer
            with desired settings.
            </summary>
            <param name="xmlSerializerFactoryMethod">
            The factory method responsible for creation of XmlSerializer.
            The factory method is called during the serialization or deserialization.<br/>
            The factory method can be called from more threads at the same time, so be sure, your factory method
            is thread safe.
            </param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the xml string.
            </summary>
            <remarks>
            It internally XmlSerializer provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>xml string</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <remarks>
            It internally XmlSerializer provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.NamespaceDoc">
            <summary>
            The namespace contains the supporting functionality for queueing and processing messages with multiple threads.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThreadInvoker">
            <summary>
            Represents the thread processing enqueued Activity delegates in the single working thread.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDispatcherFactory">
            <summary>
            Declares the factory creating the one-way dispatcher.
            </summary>
            <remarks>
            The one-way dispatcher sends messages to all attached output channels.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDispatcherFactory.CreateDispatcher">
            <summary>
            Creates the dispatcher.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory">
            <summary>
            Declares the factory for creating channel wrappers and and channel unwrappers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateChannelWrapper">
            <summary>
            Creates the channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the channel unwrapper.
            </summary>
            <param name="outputMessagingSystem">Messaging used to create output channels where unwrapped messages will be sent.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateDuplexChannelWrapper">
            <summary>
            Creates the duplex channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateDuplexChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the duplex channel unwrapper.
            </summary>
            <param name="outputMessagingSystem">Messaging used to create output channels where unwrapped messages will be sent.</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory">
            <summary>
            Implementats the messaging system delivering messages via named pipes.
            </summary>
            <remarks>
            It creates the communication channels for sending and receiving messages with using Named Pipes.
            The channel id must be a valid URI address. E.g.: net.pipe//127.0.0.1/SomeName/ . <br/>
            Notice, Silverlight and Windows Phone 7 do not support Named Pipes.
            Therefore, this functionality is not available for these platforms.
            <br/><br/>
            The input channel creates the pipe for the reading and waits for connections. To handle more connections
            in parallel there are more threads serving them (by default 10 threads). Every such thread waits
            for messages and puts them to the message queue. The message queue is connected to one working thread
            that removes messages one by one and notifies subscribers of the input channel.
            Therefore the subscribers are notified always from the same working thread.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory with default parameters.
            </summary>
            <remarks>
            The default parameters are: 10 serving threads, 10 seconds timeout for the disconnection.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs the factory specifying the number of processing threads in the input channel and the timeout
            for the output channel.
            </summary>
            <param name="numberOfInputchannelListeningThreads">
            Number of threads that will listen in parallel in input channels created by the factory.
            The maximum number is 254. Many threads can increase the number of processing connections at the same time
            but it consumes a lot of resources.
            </param>
            <param name="pipeConnectionTimeout">
            The maximum time in miliseconds, the output channel waits to connect the pipe and sends the message.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.#ctor(System.Int32,System.Int32,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter{System.Byte[]})">
            <summary>
            Constructs the factory specifying the number of processing threads in the input channel and the timeout
            for the output channel. It also allows to specify the security settings for the pipe.
            </summary>
            <remarks>
            Security settings can be needed, if communicating processes run under different integrity levels.
            E.g. If the service runs under administrator account and the client under some user account,
            then the communication will not work until the pipe security is not set.
            (Client will get access denied exception.)
            <example>
            The following example shows how to set the pipe security on the service running under administrator
            account to be accessible from client processes.
            <code>
            PipeSecurity aPipeSecurity = new PipeSecurity();
            
            // Set to low integrity level.
            aPipeSecurity.SetSecurityDescriptorSddlForm("S:(ML;;NW;;;LW)");
            
            SecurityIdentifier aSid = new SecurityIdentifier(WellKnownSidType.WorldSid, null);
            ipeAccessRule aPipeAccessRule = new PipeAccessRule(aSid, PipeAccessRights.ReadWrite, AccessControlType.Allow);
            aPipeSecurity.AddAccessRule(aPipeAccessRule);
            
            // Create the messaging communicating via Named Pipes.
            IMessagingSystemFactory aMessagingSystem = new NamedPipeMessagingSystemFactory(10, 10000, aPipeSecurity);
            </code>
            </example>
            </remarks>
            <param name="numberOfInputchannelListeningThreads">
            Number of threads that will listen in parallel in input channels created by the factory.
            The maximum number is 254. Many threads can increase the number of processing connections at the same time
            but it consumes a lot of resources.
            </param>
            <param name="pipeConnectionTimeout">
            The maximum time in miliseconds, the output channel waits to connect the pipe and sends the message.</param>
            <param name="protocolFormatter">formatter of low-level messages between channels</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.#ctor(System.Int32,System.Int32,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter{System.Byte[]},System.IO.Pipes.PipeSecurity)">
            <summary>
            Constructs the factory specifying the number of processing threads in the input channel and the timeout
            for the output channel. It also allows to specify the security settings for the pipe.
            </summary>
            <remarks>
            Security settings can be needed, if communicating processes run under different integrity levels.
            E.g. If the service runs under administrator account and the client under some user account,
            then the communication will not work until the pipe security is not set.
            (Client will get access denied exception.)
            <example>
            The following example shows how to set the pipe security on the service running under administrator
            account to be accessible from client processes.
            <code>
            PipeSecurity aPipeSecurity = new PipeSecurity();
            
            // Set to low integrity level.
            aPipeSecurity.SetSecurityDescriptorSddlForm("S:(ML;;NW;;;LW)");
            
            SecurityIdentifier aSid = new SecurityIdentifier(WellKnownSidType.WorldSid, null);
            ipeAccessRule aPipeAccessRule = new PipeAccessRule(aSid, PipeAccessRights.ReadWrite, AccessControlType.Allow);
            aPipeSecurity.AddAccessRule(aPipeAccessRule);
            
            // Create the messaging communicating via Named Pipes.
            IMessagingSystemFactory aMessagingSystem = new NamedPipeMessagingSystemFactory(10, 10000, aPipeSecurity);
            </code>
            </example>
            </remarks>
            <param name="numberOfInputchannelListeningThreads">
            Number of threads that will listen in parallel in input channels created by the factory.
            The maximum number is 254. Many threads can increase the number of processing connections at the same time
            but it consumes a lot of resources.
            </param>
            <param name="pipeConnectionTimeout">
            The maximum time in miliseconds, the output channel waits to connect the pipe and sends the message.</param>
            <param name="protocolFormatter">formatter of low-level messages between channels</param>
            <param name="pipeSecurity">
            Pipe security used in input channels.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to specified input channel by using named pipes.
            </summary>
            <remarks>
            The output channel can send messages only to the input channel and not to the duplex input channel.
            </remarks>
            <param name="channelId">Identifies the receiving input channel. The channel id represents the name of the pipe and must be a valid Uri address e.g. net.pipe//127.0.0.1/SomeName/ </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel by using the named pipe.
            </summary>
            <remarks>
            The input channel can receive messages only from the output channel and not from the duplex output channel.
            </remarks>
            <param name="channelId">Identifies this input channel. The channel id represents the name of the pipe and must be a valid URI address e.g. net.pipe//127.0.0.1/SomeName/ </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using Named Pipe.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id represents the name of the pipe and must be a valid Uri address e.g. net.pipe//127.0.0.1/SomeName/ </param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using Named Pipe.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id represents the name of the pipe and must be a valid Uri address e.g. net.pipe//127.0.0.1/SomeName/ </param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel. The id cannot be an Uri address. It must be a plain srting.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using Named Pipe.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">Identifies this duplex input channel. The channel id represents the name of the pipe and must be a valid Uri address e.g. net.pipe//127.0.0.1/SomeName/ </param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs">
            <summary>
            Event argument representing the response receiver on the service site.
            </summary>
            <remarks>
            This event argument is typically used e.g. when the client opened/closed connection. 
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.#ctor(System.String,System.String)">
            <summary>
            Constructs the event argument.
            </summary>
            <param name="responseReceiverId">Unique logical id identifying the receiver of response messages.</param>
            <param name="senderAddress">Address where the sender of the request message is located. (e.g. IP address of the client)<br/>
            Can be empty string if not applicable in used messaging.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.ResponseReceiverId">
            <summary>
            Returns the unique logical id identifying the receiver of response messages.
            </summary>
            <remarks>
            This id identifies who receives the response message on the client side.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.SenderAddress">
            <summary>
            Returns the address where the sender of the request message is located. (e.g. IP address of the client).
            It can be empty string if not applicable for used messaging.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.EConcurrencyMode">
            <summary>
            Represents threading modes for processing received messages.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.MessagingSystemBase.EConcurrencyMode.Synchronous">
            <summary>
            All received messages are synchronized via one thread.
            </summary>
            <remarks>
            E.g. if the duplex input channel receives messages from two connected duplex output channels
            they are notified to the user code one by one via one thread.
            </remarks>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.MessagingSystemBase.EConcurrencyMode.ConcurrentConnections">
            <summary>
            Particular connections are processed in parallel. 
            </summary>
            <remarks>
            E.g. if the duplex input channel receives messages from two connected duplex output channels
            they are notified to the user code in two separate threads.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter">
            <summary>
            Implements the protocol formatter encoding the low-level messages into the string.
            </summary>
            <remarks>
            Encoding to the string can be used if the messaging system does not allow tu use byte[].
            E.g. the messaging between Silverlight applications sends only string messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Encodes open connection request.
            </summary>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Encodes close connection request.
            </summary>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.EncodeMessage(System.String,System.Object)">
            <summary>
            Encodes a message or a response message.
            </summary>
            <param name="responseReceiverId">client id</param>
            <param name="message">the serialized content of the message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.EncodePollRequest(System.String)">
            <summary>
            Encodes poll request.
            </summary>
            <remarks>
            Polling is used e.g. in HTTP messaging to get response messages from the service.
            </remarks>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes a message or a response message from the stream.
            </summary>
            <param name="readStream">stream containing the low-level message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.DecodeMessage(System.String)">
            <summary>
            Decodes a message or a response message from the byte[].
            </summary>
            <param name="encodedMessage">source of the low-level message</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.ConnectionProviderFactory">
            <summary>
            Implements the factory to create the connection provider. The connection provider
            helps to attach a channel to a component or to connect two components with a channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.ConnectionProviderFactory.CreateConnectionProvider(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the connection provider.
            </summary>
            <param name="messagingSystem">Messaging system the connection provider will use to create channels.</param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1">
            <summary>
            The event when a typed sequenced message is received.
            </summary>
            <typeparam name="_RequestType">The type of the message.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.#ctor(System.String,Eneter.Messaging.EndPoints.TypedSequencedMessages.RequestMessageFragment{`0})">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseReceiverId">identifies the client where the response message can be sent</param>
            <param name="dataFragment">message fragment</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.#ctor(System.String,System.Exception)">
            <summary>
            Constructs the event from the exception.
            </summary>
            <param name="responseReceiverId">identifies the client where the response message can be sent</param>
            <param name="receivingError">error detected during receiving the message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.ResponseReceiverId">
            <summary>
            Returns the client identifier where the response can be sent.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.SequenceId">
            <summary>
            Returns the sequence identifier.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.IsSequenceCompleted">
            <summary>
            Returns true if the sequence is completed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.RequestMessage">
            <summary>
            Returns message inputData of the specified type.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            E.g. during the deserialization of the message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageSender`1.SendMessage(`0,System.String,System.Boolean)">
            <summary>
            Sends the message of specified type as a fragment of a sequence.
            </summary>
            <param name="message">typed message</param>
            <param name="sequenceId">sequence identifier</param>
            <param name="isSequenceCompleted">flag indicating if the sequence is completed</param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs">
            <summary>
            Declares the event type when the request message is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.#ctor(System.String,System.String)">
            <summary>
            Constructs the event from thr parameters.
            </summary>
            <param name="requestMessage"></param>
            <param name="responseReceiverId"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.RequestMessage">
            <summary>
            Returns the request message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.ResponseReceiverId">
            <summary>
            Returns the response receiver id.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.EProcessingStrategy">
            <summary>
            Lists possibilities how the command will process requests for execution.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.EProcessingStrategy.SingleThread">
            <summary>
            All requests to execute the command are queued and processed by one thread.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.EProcessingStrategy.MultiThread">
            <summary>
            All requests to execute the command are executed immediately in separate threads.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.NamespaceDoc">
            <summary>
            Functionality for tracing and debug purposes.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.NamespaceDoc">
            <summary>
            Functionality for writing and reading messages from a stream.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.DataContractJsonStringSerializer">
            <summary>
            Implements the serialization/deserialization to/from JSON string.
            The serializer is based on DataContractJsonSerializer provided by .Net and it supports
            attributes (DataContract, DataMember, ...) specifying how data is serialized/deserialized.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractJsonStringSerializer.#ctor">
            <summary>
            Creates the serializer based on DataContractSerializer with default settings.
            </summary>
            <remarks>
            XmlDictionaryReaderQuotas are set to Max values.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractJsonStringSerializer.#ctor(System.Xml.XmlDictionaryReaderQuotas)">
            <summary>
            Creates serializer based on DataContractJsonSerializer.
            </summary>
            <param name="quotas">various quotas vsalues for the deserialization.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractJsonStringSerializer.#ctor(System.Xml.XmlDictionaryReaderQuotas,System.Func{System.Type,System.Runtime.Serialization.XmlObjectSerializer})">
            <summary>
            Creates the serializer that allows user to specify his own method to instantiate DataContractJsonSerializer
            with desired settings.
            </summary>
            <param name="quotas">various quotas vsalues for the deserialization.</param>
            <param name="dataContractFactoryMethod">
            The factory method responsible for creation of DataContractJsonSerializer.
            The factory method is called during the serialization or deserialization.<br/>
            The factory method can be called from more threads at the same time, so be sure, your factory method
            is thread safe.
            </param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractJsonStringSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the JSON string.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>JSON string</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractJsonStringSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes JSON string into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data serialized in JSON string.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.DispatcherFactory">
            <summary>
            Implements the factory to create the one-way dispatcher.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.DispatcherFactory.CreateDispatcher">
            <summary>
            Creates the dispatcher.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory">
            <summary>
            Implements the factory for creating channel wrapper and unwrapper.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.#ctor">
            <summary>
            Constructs the channel wrapper factory with XmlStringSerializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the channel wrapper factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateChannelWrapper">
            <summary>
            Creates channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates channel unwrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateDuplexChannelWrapper">
            <summary>
            Creates duplex channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateDuplexChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates duplex channel unwrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer">
            <summary>
            HTTP policy server needed for the communication with Silverlight applications.
            </summary>
            <remarks>
            The policy server is required by Silverlight for the communication via HTTP or TCP.
            (See also <see cref="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer"/>.)
            Windows Phone 7 (based on Silverlight 3 too) does not require the policy server.
            <br/><br/>
            The HTTP policy server is a special service listening to the HTTP root address. When it receives the
            request with the path '/clientaccesspolicy.xml', it returns the content of the policy file.
            <br/><br/>
            Silverlight automatically uses this service before an HTTP request is invoked.
            If the Silverlight application invokes the HTTP request (e.g. http://127.0.0.1/MyService/),
            Silverlight first sends the request on the root (i.e. http://127.0.0.1/) and expects the policy file.
            If the policy server is not there or the content of the policy file does not allow the communication,
            the original HTTP request is not performed.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer.#ctor(System.String)">
            <summary>
            Constructs the Http policy server.
            </summary>
            <param name="httpRootAddress">
            root Http address. E.g. if the serivice has the address http://127.0.0.1/MyService/, the root
            address will be http://127.0.0.1/.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer.StartPolicyServer">
            <summary>
            Starts the policy server.
            </summary>
            <remarks>
            It starts the thread listening to HTTP requests and responding the policy file.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer.StopPolicyServer">
            <summary>
            Stops the policy server.
            </summary>
            <remarks>
            It stops the listening and responding for requests.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer.GetSilverlightDefaultPolicyXml">
            <summary>
            Returns the default xml policy file.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer.HttpRootAddress">
            <summary>
            Returns the root http address, that is served by the policy server.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer.PolicyXml">
            <summary>
            Gets or sets the policy xml.
            </summary>
            <remarks>
            When the class is instantiated, the default policy file is set.
            The default policy file allows to communicate with everybody.
            <br/>
            You can use this property to set your own policy file if needed.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer.IsListening">
            <summary>
            Returns true, if this instance of policy server is listening to requests.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.NamespaceDoc">
            <summary>
            Functionality to send and receive a sequence of strongly typed messages.
            It is guaranteed that the messages will be received in the correct order (same order as sent).<br/>
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.RequestMessageFragment`1">
            <summary>
            Data used for the typed sequenced message fragment.
            The data is used to send the message fragment from a duplex output channel to a duplex input receiver.
            </summary>
            <typeparam name="_RequestType">message type</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.RequestMessageFragment`1.#ctor">
            <summary>
            Default constructor for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.RequestMessageFragment`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>
            Constructor creating the typed message fragment from the given input parameters.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.RequestMessageFragment`1.FragmentData">
            <summary>
            Returns serialized fragment value.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.DuplexTypedSequencedMessagesFactory">
            <summary>
            Implements the factory to create duplex typed sequenced message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.DuplexTypedSequencedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with the xml string serializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.DuplexTypedSequencedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with the specified serializer.
            </summary>
            <param name="serializer"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.DuplexTypedSequencedMessagesFactory.CreateDuplexTypedSequencedMessageSender``2">
            <summary>
            Creates the duplex typed sequenced message sender.
            </summary>
            <typeparam name="_ResponseType">The type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">The type of sending messages.</typeparam>
            <returns>duplex typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.DuplexTypedSequencedMessagesFactory.CreateDuplexTypedSequencedMessageReceiver``2">
            <summary>
            Creates the duplex typed sequences message receiver.
            </summary>
            <typeparam name="_ResponseType">The type of sending response messages.</typeparam>
            <typeparam name="_RequestType">The type of receiving messages.</typeparam>
            <returns>duplex typed sequenced message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer">
            <summary>
            Serializer using Rijndael encryption.
            </summary>
            <remarks>
            The serializer internally uses some other serializer to serialize and deserialize data.
            Then it uses Rijndael to encrypt and decrypt the data.
            <br/><br/>
            Notice, the Rijndael encryption is not available in Silverlight platform.
            <example>
            Encrypted serialization with <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>
            <code>
            // Create the serializer. The defualt constructor uses XmlStringSerializer.
            RijndaelSerializer aSerializer = new RijndaelSerializer("My password.");
            
            // Create some data to be serialized.
            MyData aData = new MyData();
            ...
            
            // Serialize data with using Rijndael.
            object aSerializedData = aSerializer.Serialize&lt;MyData&gt;(aData);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.#ctor(System.String)">
            <summary>
            Constructs the serializer. It uses <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/> as the underlying serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.#ctor(System.String,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.#ctor(System.String,System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
            <param name="salt">additional value used to calculate the key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.#ctor(System.String,System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Int32)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate the key</param>
            <param name="salt">additional value used to calculate the key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
            <param name="keyBitSize">bit size of the key e.g. 128, 256</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Security.Cryptography.DeriveBytes,System.Int32)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
            <param name="passwordBasedKeyGenerator">generator of key from the password</param>
            <param name="keyBitSize">bit size of the key</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the object.
            The returned object is type of byte[]. Returned bytes are encrypted.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Encrypted data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelUnwrapper.OnMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs)">
            <summary>
            The method is called when the channel unwrapper receives a messae to be unwrapped and sent to the
            correct output channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.EBrokerRequest">
            <summary>
            Specifies the broker request.
            </summary>
            <remarks>
            The request for the broker is the message that is intended for the broker and not for the subscribers.
            This message is used by the broker client to subscribe and unsubscribe.
            </remarks>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.Subscribe">
            <summary>
            Request to subscribe exactly for the specified message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.SubscribeRegExp">
            <summary>
            Request to subscribe for message type ids that match with the regular expression.
            I.e. regular expression is used to identify what message types shall be notified
            to the client.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.Unsubscribe">
            <summary>
            Request to unsubscribe from exactly specified message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.UnsubscribeRegExp">
            <summary>
            Request to unsubscribe the regular expression.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.UnsubscribeAll">
            <summary>
            Request to unsubscribe all messages and regular expressions.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.BrokerRequestMessage">
            <summary>
            The class represents the data structure used to send requests to the broker.
            </summary>
            <remarks>
            The request for the broker is the message that is intended for the broker and not for the subscribers.
            This message is used by the broker client to subscribe and unsubscribe.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerRequestMessage.#ctor">
            <summary>
            Default constructor used for serialization/deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerRequestMessage.#ctor(Eneter.Messaging.Nodes.Broker.EBrokerRequest,System.String[])">
            <summary>
            Creates the request from input parameters.
            </summary>
            <param name="request">subscribe or unsubscribe request</param>
            <param name="messageTypes">message types that shall be subscribed or unsubscribed</param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerRequestMessage.Request">
            <summary>
            Type of the request.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerRequestMessage.MessageTypes">
            <summary>
            Array of message types.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transferring messages via WebSockets.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketInputChannel.HandleConnection(Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext)">
            <summary>
            The method is called in a separate thread when the connection is established.
            </summary>
            <param name="client"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer">
            <summary>
            TCP policy server needed for the communication with Silverlight applications.
            </summary>
            <remarks>
            The policy server is required by Silverlight for the communication via HTTP or TCP.
            (See also <see cref="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer"/>.)
            <br/><br/>
            The TCP policy server is a special service listening on the port 943 (by default for all Ip adresses).
            When it receives &lt;policy-file-request/&gt; request, it returns the content of the policy file.
            <br/><br/>
            Silverlight automatically uses this service before the TCP connection is created.
            If a Silverlight application wants to open the TCP connection,
            Silverlight first sends the request on the port 943 and expects the policy file.
            If the policy server is not there or the content of the policy file does not allow
            the communication, the Tcp connection is not created.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer.#ctor">
            <summary>
            Constructs the TCP policy server providing the policy file on the port 943 for all IP addresses.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer.#ctor(System.Net.IPAddress)">
            <summary>
            Constructs the TCP policy server for the specified IP address.
            </summary>
            <param name="ipAddress"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer.StartPolicyServer">
            <summary>
            Starts the policy server.
            </summary>
            <remarks>
            It starts the thread listening to requests on port 943 and responding the policy XML.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer.StopPolicyServer">
            <summary>
            Stops the policy server.
            </summary>
            <remarks>
            It stops the listening and responding for requests.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer.GetSilverlightDefaultPolicyXml">
            <summary>
            Returns the default xml policy file.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer.PolicyXml">
            <summary>
            Gets or sets the policy xml.
            </summary>
            <remarks>
            When the class is instantiated, the default policy XML is set.
            The default policy XML allows the communication with everybody on all Silverlight ports 4502 - 4532.
            <br/>
            You can use this property to set your own policy file if needed.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer.IsListening">
            <summary>
            Returns true, if this instance of policy server is listening to requests.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpDuplexInputChannel.SendResponseMessage(System.String,System.Object)">
            <summary>
            Sends the response message back to the TcpDuplexOutputChannel.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpDuplexInputChannel.HandleConnection(System.Net.Sockets.TcpClient)">
            <summary>
            The method is called in a separate thread when the connection is established.
            </summary>
            <param name="tcpClient"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpDuplexInputChannel.TClient">
            <summary>
            The internal class representing the connection with the client.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpDuplexInputChannel.TClient.TcpClient">
            <summary>
            Returns Tcp client.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpDuplexInputChannel.TClient.CommunicationStream">
            <summary>
            Returns the stream that shall be used to receive messages and send response messages.
            Note: If the communication is secured, then it returns the secure stream.
                  If the communication is not secured, then it returns TcpClient.GetStream().
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.SimpleOutputChannel">
            <summary>
            Internal basic implementation for the output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpListenerProvider.DoListening">
            <summary>
            Loop for the main listening thread.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory">
            <summary>
            Extends the communication by the buffered messaging and the network connection monitoring.
            </summary>
            <remarks>
            This is the composite messaging system that consist of:
            <ol>
            <li>Buffered Messaging  --&gt; buffering messages if disconnected (while automatically trying to reconnect)</li>
            <li>Monitored Messaging --&gt; constantly monitoring the connection</li>
            <li>Messaging System    --&gt; responsible for sending and receiving messages</li>
            </ol>
            The buffer stores messages if the connection is not open. The connection monitor constantly checks if the connection
            is established. See also <see cref="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory"/> and <see cref="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory"/>.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            The serializer for the 'ping' messages checking the connection is set to <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The maximum offline time is set to 10 seconds.
            The duplex output channel will check the connection with the 'ping' once per second and the response must be received within 2 seconds.
            Otherwise the connection is closed.<br/>
            The duplex input channel expects the 'ping' request at least once per 2 seconds. Otherwise the duplex output
            channel is disconnected.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with the specified parameters.
            </summary>
            <remarks>
            The maximum offline time is set to 10 seconds.
            The duplex output channel will check the connection with the 'ping' once per second and the response must be received within 2 seconds.
            Otherwise the connection is closed.<br/>
            The duplex input channel expects the 'ping' request at least once per 2 seconds. Otherwise the duplex output
            channel is disconnected.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system</param>
            <param name="serializer">serializer used to serialize the 'ping' requests</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory with the specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system</param>
            <param name="serializer">serializer used to serialize the 'ping' requests</param>
            <param name="maxOfflineTime">the maximum time, the messaging can work offline. When the messaging works offline,
            the sent messages are buffered and the connection is being reopened. If the connection is
            not reopen within maxOfflineTime, the connection is closed.
            </param>
            <param name="pingFrequency">how often the connection is checked with the 'ping' requests.</param>
            <param name="pingResponseTimeout">the maximum time, the response for the 'ping' is expected.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the input channel.
            </summary>
            <remarks>
            This output channel provides the buffered messaging. Since the the output channel does not maintain open
            connection, the connection monitoring is not applicable.<br/>
            If the input channel is not available, the sent messages are stored in the buffer from where they are sent again
            when the input channel is available.
            If the message is not sent from the buffer (because the input channel is not available) within the specified offline time,
            the message is removed from the buffer.
            <br/>
            Notice, when the message was successfully sent, it does not mean the message was delivered. It still can be lost on the way.
            <br/>
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel.
            </summary>
            <remarks>
            The buffering as well as the connection monitoring are not applicable.
            This method just uses the underlying messaging system to create the input channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the buffered messaging and the connection monitoring.
            The channel regularly checks if the connection is available. It sends 'ping' requests and expects 'ping' responses
            within the specified time. If the 'ping' response does not come, the buffered messaging layer is notified,
            that the connection was interrupted.
            The buffered messaging then tries to reconnect and stores sent messages to the buffer.
            If the connection is open, the buffered messages are sent.
            If the reconnection was not successful, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/>
            and deletes messages from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the buffered messaging and the connection monitoring.
            The channel regularly checks if the connection is available. It sends 'ping' requests and expects 'ping' responses
            within the specified time. If the 'ping' response does not come, the buffered messaging layer is notified,
            that the connection was interrupted.
            The buffered messaging then tries to reconnect and stores sent messages to the buffer.
            If the connection is open, the buffered messages are sent.
            If the reconnection was not successful, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/>
            and deletes messages from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">the unique id of this response receiver</param>
            <returns>composit duplex output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            This duplex input channel provides the buffered messaging and the connection monitoring.
            The channel regularly checks if the duplex output channel is still connected. It expect, that every connected duplex output channel
            sends regularly 'ping' messages. If the 'ping' message from the duplex output channel is not received within the specified
            time, the duplex output channel is disconnected and the buffered messaging (as the layer above) is notified about the
            disconnection.
            The buffered messaging then puts all sent response messages to the buffer and waits whether the duplex output channel reconnects.
            If the duplex output channel reopens the connection, the buffered response messages are sent.
            If the duplex output channel does not reconnect, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected"/> is invoked and rsponse messages are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex input channel with the buffer <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexInputChannel"/></returns>
        </member>
    </members>
</doc>
